{"post_stream":{"posts":[{"id":44094,"name":null,"username":"vmost","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png","created_at":"2022-01-10T16:23:15.122Z","cooked":"\u003cp\u003eI am building a component that creates a long-lived object. The object’s hot path contains two vectors with unknown size (in the worst case). These vectors require two allocations, and the vectors can’t be naively cached in a member variable because the hot path could be called recursively (e.g. how Object.SendEvent() can be called recursively, so that function unavoidably contains a HashMap allocation).\u003c/p\u003e\n\u003cp\u003eThis \u003ca href=\"https://www.youtube.com/watch?v=Tof5pRedskI\" rel=\"noopener nofollow ugc\"\u003eCPPCON talk\u003c/a\u003e introduced me to ‘polymorphic memory resources’. Basically, pmr lets you cache a memory buffer (which can be defined on the stack or heap), then allocate out of that memory buffer. If you are using the default allocator to set the memory buffer (e.g. the normal heap allocator), then when the buffer is fully used it will re-allocate a larger buffer. If you initialize with a static buffer (e.g. a \u003ccode\u003echar static_buffer[256];\u003c/code\u003e), then the buffer size is fixed.\u003c/p\u003e\n\u003cp\u003eUnfortunately, the STL only has pmr in C++17, and clang doesn’t even support it yet. Instead, Boost’s pmr has much more compiler support.\u003c/p\u003e\n\u003cp\u003eHere is how I used it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003e# CMakeLists.txt\n\nfind_package(Boost 1.6 REQUIRED COMPONENTS container)\ntarget_link_library(my_target PRIVATE Boost::container)\ntarget_include_directories(my_target PUBLIC ${Boost_INCLUDE_DIRS})\n\n\n# object.h\n\n#include \"boost/container/pmr/monotonic_buffer_resource.hpp\"\n#include \"boost/container/pmr/polymorphic_allocator.hpp\"\n#include \"boost/container/pmr/unsynchronized_pool_resource.hpp\"\n#include \"boost/container/pmr/vector.hpp\"\n\nusing MyType_Vec_t = boost::container::pmr::vector\u0026lt;MyType\u0026gt;;\n\nnamespace config\n{\n    const std::size_t default_buffer_size{256};\n}\n\nclass MyObject\n{\npublic:\n    MyObject() :\n        m_pmr_buffer{config::default_buffer_size},  //start with some memory so the first use of the buffer doesn't require an allocation\n        m_pmr_resource{\u0026amp;m_pmr_buffer},\n        m_pmr_allocator_MyType{\u0026amp;m_pmr_resource}\n    {}\n    ...\n    void DoSomething();\n\nprivate:\n    boost::container::pmr::monotonic_buffer_resource m_pmr_buffer;\n    boost::container::pmr::unsynchronized_pool_resource m_pmr_resource;\n    boost::container::pmr::polymorphic_allocator\u0026lt;MyType\u0026gt; m_pmr_allocator_MyType;\n}\n\n\n# object.cpp\n\n#include \"object.h\"\n\nvoid MyObject::DoSomething()\n{\n    MyType_Vec_t new_vector{m_pmr_allocator_MyType};\n\n    new_vector.reserve(10);  //ask m_pmr_resource for an allocation, which gets memory from m_pmr_buffer\n\n    ...\n} //~new_vector(): m_pmr_resource releases the memory back to m_pmr_buffer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI don’t have rigorous performance numbers, but the impact is significant if you are reusing the pmr objects many times (and your worst-case doesn’t cause memory exhaustion).\u003c/p\u003e","post_number":1,"post_type":1,"updated_at":"2022-01-10T16:23:15.122Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":15,"reads":19,"readers_count":18,"score":78.8,"yours":false,"topic_id":7122,"topic_slug":"faster-allocations-with-pmr","display_username":null,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"https://www.youtube.com/watch?v=Tof5pRedskI","internal":false,"reflection":false,"title":"Real-time Programming with the C++ Standard Library - Timur Doumler - CppCon 2021 - YouTube","clicks":1},{"url":"https://discourse.urho3d.io/t/custom-memory-allocation/7245/4","internal":true,"reflection":true,"title":"Custom memory allocation","clicks":0}],"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":1363,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":44095,"name":null,"username":"vmost","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png","created_at":"2022-01-10T16:42:29.752Z","cooked":"\u003cp\u003eI suspect this mechanism could be very useful in the engine (although it may fall apart on deeper inspection). Suppose \u003ccode\u003eContext\u003c/code\u003e owns the monotonic buffer and pool resource. Different places that require allocations (especially \u003ccode\u003eObject.SendEvent()\u003c/code\u003e) can dip into that resource pool at-will. Since allocations are one of the largest burdens outside rendering, this approach could have non-trivial and large scale benefits.\u003c/p\u003e\n\u003cp\u003eOne concern is that every time the buffer needs to increase in size, it must reallocate the entire thing. This may be very expensive if the buffer gets large. I’m also not 100% sure if reallocating the buffer would invalidate iterators. EDIT: Nvm, it does not reallocate the entire thing - just adds more memory.\u003c/p\u003e\n\u003cp\u003eEDIT: It looks like \u003ccode\u003emonotonic_buffer_resource\u003c/code\u003e is only useful if you want the pool to obtain memory from a static buffer, or a dynamic buffer with an initial size. Otherwise the pool can exist on its own, obtaining more memory from the default allocator ad hoc when it runs out. One advantage of a standalone-pool is you can use \u003ccode\u003esynchronized_pool_resource\u003c/code\u003e for thread safety (\u003ccode\u003emonotonic_buffer_resource\u003c/code\u003e isn’t thread-safe).\u003c/p\u003e","post_number":2,"post_type":1,"updated_at":"2022-01-10T17:55:02.088Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":17,"readers_count":16,"score":18.4,"yours":false,"topic_id":7122,"topic_slug":"faster-allocations-with-pmr","display_username":null,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":2,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[{"id":2,"count":1}],"moderator":false,"admin":false,"staff":false,"user_id":1363,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false}],"stream":[44094,44095]},"timeline_lookup":[[1,317],[2,316]],"suggested_topics":[{"id":7216,"title":"Why occlusion culling rasterization is implemented by software?","fancy_title":"Why occlusion culling rasterization is implemented by software?","slug":"why-occlusion-culling-rasterization-is-implemented-by-software","posts_count":4,"reply_count":2,"highest_post_number":4,"image_url":null,"created_at":"2022-03-11T11:36:18.222Z","last_posted_at":"2022-03-13T02:39:16.613Z","bumped":true,"bumped_at":"2022-03-13T02:39:16.613Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":193,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":1490,"username":"Sunc","name":"DoubleSuper","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/df788c/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":484,"username":"Eugene","name":"Eugene Kozlov","avatar_template":"/user_avatar/discourse.urho3d.io/eugene/{size}/902_2.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":1358,"username":"JSandusky","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/jsandusky/{size}/3220_2.png"}}]},{"id":7227,"title":"How to use -s MAX_WEBGL_VERSION=2","fancy_title":"How to use -s MAX_WEBGL_VERSION=2","slug":"how-to-use-s-max-webgl-version-2","posts_count":3,"reply_count":1,"highest_post_number":3,"image_url":null,"created_at":"2022-03-30T13:12:17.248Z","last_posted_at":"2022-03-30T14:09:14.646Z","bumped":true,"bumped_at":"2022-03-30T14:09:14.646Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":103,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster","user":{"id":997,"username":"huminzheng","name":"huminzheng","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/h/9de0a6/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}}]},{"id":7136,"title":"Open-source ocean shader system","fancy_title":"Open-source ocean shader system","slug":"open-source-ocean-shader-system","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-01-19T23:11:15.784Z","last_posted_at":"2022-01-19T23:11:15.858Z","bumped":true,"bumped_at":"2022-01-19T23:11:15.858Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":177,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":1304,"username":"lebrewer","name":"lebrewer","avatar_template":"/user_avatar/discourse.urho3d.io/lebrewer/{size}/2811_2.png"}}]},{"id":7211,"title":"Particle is low","fancy_title":"Particle is low","slug":"particle-is-low","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2022-03-03T13:52:14.991Z","last_posted_at":"2022-04-20T05:18:36.122Z","bumped":true,"bumped_at":"2022-04-20T05:18:36.122Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":232,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":1503,"username":"tianlv777","name":"zerrrrr","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/t/a4c791/{size}.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":1491,"username":"xlat","name":"Alex Kuch","avatar_template":"/user_avatar/discourse.urho3d.io/xlat/{size}/3620_2.png"}}]},{"id":7244,"title":"Overgrowth source released","fancy_title":"Overgrowth source released","slug":"overgrowth-source-released","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2022-04-25T14:10:33.749Z","last_posted_at":"2022-04-25T17:18:36.743Z","bumped":true,"bumped_at":"2022-04-25T17:18:36.743Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":4,"views":190,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":1304,"username":"lebrewer","name":"lebrewer","avatar_template":"/user_avatar/discourse.urho3d.io/lebrewer/{size}/2811_2.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":809,"username":"elix22","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/elix22/{size}/1437_2.png"}}]}],"tags_descriptions":{},"id":7122,"title":"Faster allocations with PMR","fancy_title":"Faster allocations with PMR","posts_count":2,"created_at":"2022-01-10T16:23:15.053Z","views":209,"reply_count":0,"like_count":1,"last_posted_at":"2022-01-10T16:42:29.752Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"faster-allocations-with-pmr","category_id":16,"word_count":544,"deleted_at":null,"user_id":1363,"featured_link":null,"pinned_globally":false,"pinned_at":null,"pinned_until":null,"image_url":null,"slow_mode_seconds":0,"draft":null,"draft_key":"topic_7122","draft_sequence":null,"unpinned":null,"pinned":false,"current_post_number":1,"highest_post_number":2,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":false,"bookmarks":[],"topic_timer":null,"message_bus_last_id":0,"participant_count":1,"show_read_indicator":false,"thumbnails":null,"slow_mode_enabled_until":null,"tags_disable_ads":false,"details":{"can_edit":false,"notification_level":1,"participants":[{"id":1363,"username":"vmost","name":null,"avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png","post_count":2,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2}],"created_by":{"id":1363,"username":"vmost","name":null,"avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png"},"last_poster":{"id":1363,"username":"vmost","name":null,"avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png"},"links":[{"url":"https://www.youtube.com/watch?v=Tof5pRedskI","title":"Real-time Programming with the C++ Standard Library - Timur Doumler - CppCon 2021 - YouTube","internal":false,"attachment":false,"reflection":false,"clicks":1,"user_id":1363,"domain":"www.youtube.com","root_domain":"youtube.com"}]}}