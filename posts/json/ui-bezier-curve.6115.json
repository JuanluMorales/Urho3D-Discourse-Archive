{"post_stream":{"posts":[{"id":37489,"name":"SirNate0","username":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png","created_at":"2020-04-24T04:20:10.940Z","cooked":"\u003cp\u003eI’ve done a bit of work extending the class someone else shared previously to allow a smoother appearance and allow the curve to detect if the mouse is over it. The work is by no means finished, as I intend to have a poly-spline class as well as a class to allow the editing of curves (like Blender’s F-Curves, as well as hopefully allowing those to be exported and imported between Blender and Urho). For now, though, the UICurve class is about done.\u003c/p\u003e\n\u003cp\u003eSometime in the future I’ll go create a repository with all of these (or maybe a PR once everything is finished), but for now I thought some might find this useful even in a not-polished state.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eThe originals:\u003c/p\u003e\u003caside class=\"quote quote-modified\" data-post=\"1\" data-topic=\"2048\"\u003e\n  \u003cdiv class=\"title\"\u003e\n    \u003cdiv class=\"quote-controls\"\u003e\u003c/div\u003e\n    \u003cimg loading=\"lazy\" alt=\"\" width=\"20\" height=\"20\" src=\"https://sjc6.discourse-cdn.com/standard17/user_avatar/discourse.urho3d.io/godan/40/49_2.png\" class=\"avatar\"\u003e\n    \u003ca href=\"https://discourse.urho3d.io/t/node-graph-with-urho-ui/2048\"\u003eNode Graph with Urho UI\u003c/a\u003e \u003ca class=\"badge-wrapper  bullet\" href=\"/c/showcase/projects/12\"\u003e\u003cspan class=\"badge-category-parent-bg\" style=\"background-color: #F1592A;\"\u003e\u003c/span\u003e\u003cspan class=\"badge-category-bg\" style=\"background-color: #808281;\"\u003e\u003c/span\u003e\u003cspan style=\"\" data-drop-close=\"true\" class=\"badge-category clear-badge\" title=\"Announcements and news updates to your projects using Urho3D.\"\u003eProjects\u003c/span\u003e\u003c/a\u003e\n  \u003c/div\u003e\n  \u003cblockquote\u003e\n    There’s been a lot of talk about replacing the native Urho UI. However, after spending some serious time with it, I have to say, it has grown on me! I think a critical change was the recent decision to make UIBatch vertex data public. This meant I could create a little BezierCurve class that inherits from Sprite: \n[image] \nNothing really special yet, but it does show that possibilities! Here is my UICurve class (Disclaimer: code might be ugly - I wrote this pretty quickly). One quick request: It…\n  \u003c/blockquote\u003e\n\u003c/aside\u003e\n\n\u003chr\u003e\n\u003cp\u003eThe new ones:\u003c/p\u003e\n\u003ch3\u003e\n\u003ca name=\"uicurveh-1\" class=\"anchor\" href=\"#uicurveh-1\"\u003e\u003c/a\u003eUICurve.h\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003e#pragma once\n\n#include \u0026lt;Urho3D/UI/Sprite.h\u0026gt;\n#include \u0026lt;Urho3D/Core/Context.h\u0026gt;\n#include \u0026lt;Urho3D/UI/UIBatch.h\u0026gt;\nusing namespace Urho3D;\n\nclass URHO3D_API UICurve : public Sprite\n{\n    URHO3D_OBJECT(UICurve, Sprite)\npublic:\n    UICurve(Context* context);\n    ~UICurve() {};\n    ///segments for cuve rendering\n    int segments_ = 25;\n    ///thickness\n    float thickness_ = 25.0f;\n    ///flag for redrawing curve\n    bool isDirty = true;\n    ///define controls pts\n    Vector\u0026lt;Vector3\u0026gt; controlPoints;\n    /// Return UI rendering batches.\n    virtual void GetBatches(PODVector\u0026lt;UIBatch\u0026gt;\u0026amp; batches, PODVector\u0026lt;float\u0026gt;\u0026amp; vertexData, const IntRect\u0026amp; currentScissor);\n    void AddCurveSegment(UIBatch\u0026amp; batch, int segmentIndex, Vector3 a, Vector3 b, Vector3 c, Vector3 d);\n    ///fills the path verts vectors from the control points\n    void BezierCurve(int segments);\n    ///Helper function that offsets the path verts and fills the quads vector\n    void OffsetCurve();\n    ///update path and quads\n    void UpdatePath();\n    ///Set and end point\n    void SetEndPoint(Vector3 newPos, bool moveTangent=true);\n    ///Set start point\n    void SetStartPoint(Vector3 newPos, bool moveTangent = true);\n    ///custom update logic\n    virtual void Update(float timeStep);\n\n    virtual void OnHover(const IntVector2\u0026amp; position, const IntVector2\u0026amp; screenPosition, int buttons, int qualifiers, Cursor* cursor);\n\n    bool IsMouseOver(const IntVector2\u0026amp; point) const\n    {\n        return GetClosestPointTimeDistance(point).w_ \u0026lt;= thickness_*0.5f;\n    }\n    // Returns the closest point as (pt.x_, pt.y_, t_on_spline, distance_from_spline)\n    Vector4 GetClosestPointTimeDistance(const IntVector2\u0026amp; queryPoint) const;\n\nprivate:\n    ///pts defining segmented curve\n    Vector\u0026lt;Vector3\u0026gt; pathVerts;\n    ///quads that render the curve, by offsetting or filling it\n    Vector\u0026lt;Vector3\u0026gt; pathQuads;\n    ///Maximum angle before we just split between two quads instead of merging with the last points\n    static constexpr float MAX_SEGMENT_ANGLE = 120.0f;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\n\u003ca name=\"uicurvecpp-2\" class=\"anchor\" href=\"#uicurvecpp-2\"\u003e\u003c/a\u003eUICurve.cpp\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003e#include \u0026lt;Urho3D/Urho3D.h\u0026gt;\n\n#include \"UICurve.h\"\n\n#include \u0026lt;Urho3D/IO/Log.h\u0026gt;\n#include \u0026lt;Urho3D/UI/UI.h\u0026gt;\n\n#include \u0026lt;Urho3D/Math/Ray.h\u0026gt;\n\n#ifdef DEBUG_CURVE\n#include \u0026lt;Urho3D/Graphics/DebugRenderer.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Camera.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Graphics.h\u0026gt;\n#endif\n\nUICurve::UICurve(Context* context) : Sprite(context)\n{\n    context-\u0026gt;RegisterFactory\u0026lt;UICurve\u0026gt;(\"UI\");\n    SetName(\"UI-Curve\");\n};\n\nvoid UICurve::GetBatches(PODVector\u0026lt;UIBatch\u0026gt;\u0026amp; batches, PODVector\u0026lt;float\u0026gt;\u0026amp; vertexData, const IntRect\u0026amp; currentScissor)\n{\n    if (pathQuads.Size() \u0026lt; 4)\n        return;\n\n    bool allOpaque = true;\n    if (GetDerivedOpacity() \u0026lt; 1.0f || colors_[C_TOPLEFT].a_ \u0026lt; 1.0f || colors_[C_TOPRIGHT].a_ \u0026lt; 1.0f ||\n        colors_[C_BOTTOMLEFT].a_ \u0026lt; 1.0f || colors_[C_BOTTOMRIGHT].a_ \u0026lt; 1.0f)\n        allOpaque = false;\n\n    const IntVector2\u0026amp; size = GetSize();\n    UIBatch\n        batch(this, blendMode_ == BLEND_REPLACE \u0026amp;\u0026amp; !allOpaque ? BLEND_ALPHA : blendMode_, currentScissor, texture_, \u0026amp;vertexData);\n\n    //iterate over pathQuads and push to batch\n    for (int i = 0; i \u0026lt; pathQuads.Size()/4; i ++)\n    {\n        //adjust ordering for render\n        Vector3 a = pathQuads[4 * i];\n        Vector3 b = pathQuads[4 * i + 1];\n        Vector3 c = pathQuads[4 * i + 2];\n        Vector3 d = pathQuads[4 * i + 3];\n\n        AddCurveSegment(batch, i, a, b, c, d);\n    }\n\n    UIBatch::AddOrMerge(batch, batches);\n\n    // Reset hovering for next frame\n    hovering_ = false;\n}\n\nvoid UICurve::Update(float timeStep)\n{\n    auto pt = GetSubsystem\u0026lt;UI\u0026gt;()-\u0026gt;GetCursorPosition();\n    if (IsMouseOver(pt))\n        colors_[0] = Color::YELLOW;\n    else\n        colors_[0] = Color::MAGENTA;\n    UpdatePath();\n}\n\nvoid UICurve::OnHover(const IntVector2\u0026amp; position, const IntVector2\u0026amp; screenPosition, int buttons, int qualifiers, Cursor* cursor)\n{\n    colors_[0] = Color::GREEN;\n    UpdatePath();\n\n}\n\nPair\u0026lt;float, float\u0026gt; /*__attribute__((optimize(\"O0\")))*/ DistanceAndDistanceAlongPtToLineSeg(const Vector3\u0026amp; point, const Vector3\u0026amp; lineA, const Vector3\u0026amp; lineB)\n{\n    // Per https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    Vector3 diff = lineB - lineA;\n    Vector3 diff2Point = (lineA - point);\n    float denom = 1.0f/diff.LengthSquared();\n\n    float d = Sqrt((diff2Point.CrossProduct(diff)).LengthSquared() * denom);\n    float t = -diff2Point.DotProduct(diff) * denom;\n    float l = diff.Length();\n    if (t \u0026gt; 1.0)\n        return {(point-lineB).Length(),1.0};\n    else if (t \u0026lt; 0.0)\n        return {diff2Point.Length(),0.0};\n    else\n        return {d,t};\n}\n\nVector4 UICurve::GetClosestPointTimeDistance(const IntVector2\u0026amp; queryPoint) const\n{\n\n    if (pathVerts.Empty())\n        return {};\n    else if (pathVerts.Size() == 1)\n    {\n        Vector2 v = {pathVerts[0].x_,pathVerts[0].y_};\n        return {v.x_,v.y_,0.0,(v - Vector2(queryPoint)).Length()};\n    }\n\n#ifdef DEBUG_CURVE\n    auto dr = GetSubsystem\u0026lt;DebugRenderer\u0026gt;();\n    auto cam = GetSubsystem\u0026lt;Camera\u0026gt;();\n    if (!dr || !cam)\n    {\n        URHO3D_LOGERROR(\"NO Debug Renderer or no Camera.\");\n        return {};\n    }\n#endif\n\n    Vector3 pt{(float)queryPoint.x_,(float)queryPoint.y_,0};\n\n    float minLength = M_INFINITY;\n    int min = -1;\n    const float t_step = 1.0f / (float)segments_;\n    float t = t_step * min;\n    float t_local = 0;\n    for (int i = 0; i \u0026lt; pathVerts.Size()-1; ++i)\n    {\n        const Vector3\u0026amp; v = pathVerts[i];\n        const Vector3\u0026amp; vNext = pathVerts[i+1];\n        Pair\u0026lt;float, float\u0026gt; distTime = DistanceAndDistanceAlongPtToLineSeg(pt,v,vNext);\n//        float length = Vector2{v.x_ - queryPoint.x_,v.y_ - queryPoint.y_}.Length();\n        if (distTime.first_ \u0026lt; minLength)\n        {\n            minLength = distTime.first_;\n            min = i;\n            t_local = distTime.second_;\n            t = t_step * min + t_local / (float) segments_;\n\n#ifdef DEBUG_CURVE\n            auto scale = Vector3(Vector2(GetSubsystem\u0026lt;Graphics\u0026gt;()-\u0026gt;GetRenderTargetDimensions()),1);\n            dr-\u0026gt;AddLine(cam-\u0026gt;ScreenToWorldPoint(v/scale+Vector3::FORWARD*0.5),cam-\u0026gt;ScreenToWorldPoint(pt/scale+Vector3::FORWARD*0.5),Color::RED,false);\n            dr-\u0026gt;AddLine(cam-\u0026gt;ScreenToWorldPoint(v.Lerp(vNext,t_local)/scale+Vector3::FORWARD*0.5),cam-\u0026gt;ScreenToWorldPoint(pt/scale+Vector3::FORWARD*0.5),Color::MAGENTA,false);\n            if (Abs(distTime.second_-0.5) \u0026lt; 0.45)\n            {\n                URHO3D_LOGERROR(String(distTime.second_));\n                URHO3D_LOGERROR(String(t_local));\n                dr-\u0026gt;AddLine(cam-\u0026gt;ScreenToWorldPoint(v.Lerp(vNext,t_local)/scale+Vector3::FORWARD*0.5),cam-\u0026gt;ScreenToWorldPoint(pt/scale+Vector3::FORWARD*0.5),Color::BLUE,false);\n            }\n            if (v.z_ != 0.0f)\n                URHO3D_LOGERROR(\"z: \" + String(v.z_));\n#endif\n        }\n    }\n\n    Vector3 interp = Lerp(pathVerts[min],pathVerts[min+1], t_local);\n\n    return {interp.x_,interp.y_,t,minLength};\n\n}\n\nvoid UICurve::UpdatePath()\n{\n    BezierCurve(segments_);\n    OffsetCurve();\n}\n\nvoid UICurve::SetStartPoint(Vector3 newPos, bool moveTangent)\n{\n    if (controlPoints.Size() \u0026lt; 4)\n    {\n        URHO3D_LOGERROR(\"Control points have not been initialize.\");\n        return;\n    }\n\n    //get move vec\n    Vector3 vec = newPos - controlPoints[0];\n    controlPoints[0] = newPos;\n\n    if (moveTangent)\n    {\n        controlPoints[1] += vec;\n    }\n\n    UpdatePath();\n}\n\nvoid UICurve::SetEndPoint(Vector3 newPos, bool moveTangent)\n{\n    if (controlPoints.Size() \u0026lt; 4)\n    {\n        URHO3D_LOGERROR(\"Control points have not been initialize.\");\n        return;\n    }\n\n    //get move vec\n    Vector3 vec = newPos - controlPoints[3];\n    controlPoints[3] = newPos;\n\n    if (moveTangent)\n    {\n        controlPoints[2] += vec;\n    }\n\n    UpdatePath();\n}\n\nvoid UICurve::BezierCurve(int segments)\n{\n    int num_segments = segments;\n    segments_ = segments;\n    float t_step = 1.0f / (float)num_segments;\n\n    //check that we have the right number of control points\n    if (controlPoints.Size() \u0026lt; 4)\n    {\n        URHO3D_LOGERROR(\"Not enough control points for Bezier curve\");\n        return;\n    }\n\n    //clear the path verts\n    pathVerts.Clear();\n\n    //push the first point\n    pathVerts.Push(controlPoints[0]);\n\n    for (int i_step = 1; i_step \u0026lt;= num_segments; i_step++)\n    {\n        float t = t_step * i_step;\n        float u = 1.0f - t;\n        float w1 = u*u*u;\n        float w2 = 3 * u*u*t;\n        float w3 = 3 * u*t*t;\n        float w4 = t*t*t;\n\n        Vector3 nextVert(w1*controlPoints[0].x_ + w2*controlPoints[1].x_ + w3*controlPoints[2].x_ + w4*controlPoints[3].x_,\n            w1*controlPoints[0].y_ + w2*controlPoints[1].y_ + w3*controlPoints[2].y_ + w4*controlPoints[3].y_);\n\n        //push the next pt\n        pathVerts.Push(nextVert);\n    }\n\n    //mark the curve for redraw\n    isDirty = true;\n}\n\nvoid UICurve::OffsetCurve()\n{\n    //check that path verts has a least two points\n    if (pathVerts.Size() \u0026lt; 2)\n    {\n        URHO3D_LOGERROR(\"Not enough path verts for curve offset\");\n        return;\n    }\n\n    float halfThickness = thickness_ * 0.5;\n\n    //clear\n    pathQuads.Clear();\n\n    //create the perp lines\n    //ordering is\n\n    /*************************************************************\n\n    0          1\n    |          |                }=halfThickness\n    |----------|---------- etc\n    |          |                }=halfThickness\n    2          3\n\n    *************************************************************/\n\n    for (int i = 0; i \u0026lt; pathVerts.Size()-1; i++)\n    {\n        if (i == 0)\n        {\n            Vector3 dirVec = pathVerts[i + 1] - pathVerts[i];\n            Vector3 perpVec(dirVec.y_, -dirVec.x_, 0);\n            perpVec.Normalize();\n\n            Vector3 p1 = pathVerts[i] + halfThickness * perpVec;\n            Vector3 p2 = pathVerts[i] - halfThickness * perpVec;\n            Vector3 p3 = pathVerts[i + 1] + halfThickness * perpVec;\n            Vector3 p4 = pathVerts[i + 1] - halfThickness * perpVec;\n\n            //push\n            pathQuads.Push(p1);\n            pathQuads.Push(p3);\n            pathQuads.Push(p2);\n            pathQuads.Push(p4);\n\n        }\n\n        else if (i == pathVerts.Size() - 2)\n        {\n            Vector3 dirVec = pathVerts[i] - pathVerts[i - 1];\n            Vector3 perpVec(dirVec.y_, -dirVec.x_, 0);\n            perpVec.Normalize();\n\n\n            Vector3 p1 = pathVerts[i] + halfThickness * perpVec;\n            Vector3 p2 = pathVerts[i] - halfThickness * perpVec;\n            Vector3 p3 = pathVerts[i + 1] + halfThickness * perpVec;\n            Vector3 p4 = pathVerts[i + 1] - halfThickness * perpVec;\n\n            //push\n            pathQuads.Push(p1);\n            pathQuads.Push(p3);\n            pathQuads.Push(p2);\n            pathQuads.Push(p4);\n\n\n        }\n\n        else\n        {\n            Vector3 dirVec = pathVerts[i + 1] - pathVerts[i];\n            Vector3 prevDirVec = pathVerts[i] - pathVerts[i - 1];\n            Vector3 perpVec(dirVec.y_, -dirVec.x_, 0);\n            Vector3 prevPerpVec(prevDirVec.y_, -prevDirVec.x_, 0);\n            perpVec.Normalize();\n            prevPerpVec.Normalize();\n            if (prevPerpVec.Angle(perpVec) \u0026gt;= MAX_SEGMENT_ANGLE)\n                prevPerpVec = perpVec;\n\n            Vector3 p1 = pathVerts[i] + halfThickness * prevPerpVec;\n            Vector3 p2 = pathVerts[i] - halfThickness * prevPerpVec;\n            Vector3 p3 = pathVerts[i + 1] + halfThickness * perpVec;\n            Vector3 p4 = pathVerts[i + 1] - halfThickness * perpVec;\n\n            //push\n            pathQuads.Push(p1);\n            pathQuads.Push(p3);\n            pathQuads.Push(p2);\n            pathQuads.Push(p4);\n        }\n    }\n}\n\n//void UICurve::BezierCurve(UIBatch\u0026amp; batch, Vector3 a, Vector3 b, Vector3 c, Vector3 d)\n//{\n//\tint num_segments = 50;\n//\tfloat t_step = 1.0f / (float)num_segments;\n//\n//\tVector3 v1, v2, v3, v4;\n//\tv1 = a;\n//\tfor (int i_step = 1; i_step \u0026lt;= num_segments; i_step++)\n//\t{\n//\t\tfloat t = t_step * i_step;\n//\t\tfloat u = 1.0f - t;\n//\t\tfloat w1 = u*u*u;\n//\t\tfloat w2 = 3 * u*u*t;\n//\t\tfloat w3 = 3 * u*t*t;\n//\t\tfloat w4 = t*t*t;\n//\n//\t\tv2 = Vector3(w1*a.x_ + w2*b.x_ + w3*c.x_ + w4*d.x_, w1*a.y_ + w2*b.y_ + w3*c.y_ + w4*d.y_);\n//\n//\t\t//URHO3D_LOGINFO(\"bezier pt: \" + String(b));\n//\n//\t\tv3 = v2 + Vector3(0, 20, 0);\n//\t\tv4 = v1 + Vector3(0, 20, 0);\n//\n//\t\tAddCurveSegment(batch, v1, v2, v4, v3);\n//\t\tv1 = v2;\n//\n//\n//\t}\n//}\n\nvoid UICurve::AddCurveSegment(UIBatch\u0026amp; batch, int segmentIndex, Vector3 a, Vector3 b, Vector3 c, Vector3 d)\n{\n    const IntVector2\u0026amp; size = GetSize();\n\n    float widthFloat = size.x_ / segments_;\n    //args\n    int x = segmentIndex * widthFloat;\n    int y = 0;\n    int width = (segmentIndex + 1) * widthFloat - x;//size.x_;\n    int height = size.y_;\n    Matrix3x4 transform = GetTransform();\n    int texOffsetX = imageRect_.left_;\n    int texOffsetY = imageRect_.top_;\n    int texWidth = imageRect_.right_ - imageRect_.left_;\n    int texHeight = imageRect_.bottom_ - imageRect_.top_;\n\n    //URHO3D_LOGINFO(\"a: \" + String(a) + \",b: \" + String(b) + \",c: \" + String(c) + \",d: \" + String(d));\n\n\n    //logic\n    unsigned topLeftColor, topRightColor, bottomLeftColor, bottomRightColor;\n\n    if (!batch.useGradient_)\n    {\n        // If alpha is 0, nothing will be rendered, so do not add the quad\n        if (!(batch.color_ \u0026amp; 0xff000000))\n            return;\n\n        topLeftColor = batch.color_;\n        topRightColor = batch.color_;\n        bottomLeftColor = batch.color_;\n        bottomRightColor = batch.color_;\n    }\n    else\n    {\n        topLeftColor = batch.GetInterpolatedColor(x, y);\n        topRightColor = batch.GetInterpolatedColor(x + width, y);\n        bottomLeftColor = batch.GetInterpolatedColor(x, y + height);\n        bottomRightColor = batch.GetInterpolatedColor(x + width, y + height);\n    }\n\n/*\tVector3 v1 = (transform * Vector3((float)x, (float)y, 0.0f)) - batch.posAdjust;\n    Vector3 v2 = (transform * Vector3((float)x + (float)width, (float)y, 0.0f)) - batch.posAdjust;\n    Vector3 v3 = (transform * Vector3((float)x, (float)y + (float)height, 0.0f)) - batch.posAdjust;\n    Vector3 v4 = (transform * Vector3((float)x + (float)width, (float)y + (float)height, 0.0f)) - batch.posAdjust*/;\n\n    Vector3 v1 = (transform * a) - batch.posAdjust;\n    Vector3 v2 = (transform * b) - batch.posAdjust;\n    Vector3 v3 = (transform * c) - batch.posAdjust;\n    Vector3 v4 = (transform * d) - batch.posAdjust;\n\n    float leftUV = 0.0f; // ((float)texOffsetX) * batch.invTextureSize_.x_;\n    float topUV = 0.0f;// ((float)texOffsetY) * batch.invTextureSize_.y_;\n    float rightUV = 1.0f;// ((float)(texOffsetX + (texWidth ? texWidth : width))) *batch.invTextureSize_.x_;\n    float bottomUV = 1.0f;// ((float)(texOffsetY + (texHeight ? texHeight : height))) * batch.invTextureSize_.y_;\n\n    unsigned begin = batch.vertexData_-\u0026gt;Size();\n    batch.vertexData_-\u0026gt;Resize(begin + 6 * UI_VERTEX_SIZE);\n    float* dest = \u0026amp;(batch.vertexData_-\u0026gt;At(begin));\n    batch.vertexEnd_ = batch.vertexData_-\u0026gt;Size();\n\n    dest[0] = v1.x_;\n    dest[1] = v1.y_;\n    dest[2] = 0.0f;\n    ((unsigned\u0026amp;)dest[3]) = topLeftColor;\n    dest[4] = leftUV;\n    dest[5] = topUV;\n\n    dest[6] = v2.x_;\n    dest[7] = v2.y_;\n    dest[8] = 0.0f;\n    ((unsigned\u0026amp;)dest[9]) = topRightColor;\n    dest[10] = rightUV;\n    dest[11] = topUV;\n\n    dest[12] = v3.x_;\n    dest[13] = v3.y_;\n    dest[14] = 0.0f;\n    ((unsigned\u0026amp;)dest[15]) = bottomLeftColor;\n    dest[16] = leftUV;\n    dest[17] = bottomUV;\n\n    dest[18] = v2.x_;\n    dest[19] = v2.y_;\n    dest[20] = 0.0f;\n    ((unsigned\u0026amp;)dest[21]) = topRightColor;\n    dest[22] = rightUV;\n    dest[23] = topUV;\n\n    dest[24] = v4.x_;\n    dest[25] = v4.y_;\n    dest[26] = 0.0f;\n    ((unsigned\u0026amp;)dest[27]) = bottomRightColor;\n    dest[28] = rightUV;\n    dest[29] = bottomUV;\n\n    dest[30] = v3.x_;\n    dest[31] = v3.y_;\n    dest[32] = 0.0f;\n    ((unsigned\u0026amp;)dest[33]) = bottomLeftColor;\n    dest[34] = leftUV;\n    dest[35] = bottomUV;\n}\n\u003c/code\u003e\u003c/pre\u003e","post_number":1,"post_type":1,"updated_at":"2020-04-24T04:20:10.940Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":44,"reads":35,"readers_count":34,"score":302.0,"yours":false,"topic_id":6115,"topic_slug":"ui-bezier-curve","display_username":"SirNate0","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"https://discourse.urho3d.io/t/node-graph-with-urho-ui/2048","internal":true,"reflection":false,"title":"Node Graph with Urho UI","clicks":0}],"read":true,"user_title":null,"bookmarked":false,"actions_summary":[{"id":2,"count":3}],"moderator":false,"admin":false,"staff":false,"user_id":628,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false}],"stream":[37489]},"timeline_lookup":[[1,943]],"suggested_topics":[{"id":7099,"title":":fallen_leaf: Polynomials \u0026 Harmonics","fancy_title":":fallen_leaf: Polynomials \u0026amp; Harmonics","slug":"polynomials-harmonics","posts_count":6,"reply_count":0,"highest_post_number":7,"image_url":null,"created_at":"2021-12-13T05:06:04.641Z","last_posted_at":"2021-12-27T23:27:39.489Z","bumped":true,"bumped_at":"2021-12-27T23:27:39.489Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"unicode_title":"🍂 Polynomials \u0026 Harmonics","tags_descriptions":{},"like_count":6,"views":392,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}}]},{"id":7103,"title":":test_tube: DebugRenderer as GUI","fancy_title":":test_tube: DebugRenderer as GUI","slug":"debugrenderer-as-gui","posts_count":4,"reply_count":1,"highest_post_number":4,"image_url":null,"created_at":"2021-12-17T02:25:06.606Z","last_posted_at":"2021-12-18T01:09:27.738Z","bumped":true,"bumped_at":"2021-12-18T01:09:27.738Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"unicode_title":"🧪 DebugRenderer as GUI","tags_descriptions":{},"like_count":4,"views":267,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":861,"username":"GodMan","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/g/e79b87/{size}.png"}}]},{"id":7110,"title":"Resource fetch define","fancy_title":"Resource fetch define","slug":"resource-fetch-define","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2021-12-27T12:28:55.126Z","last_posted_at":"2021-12-27T17:00:37.699Z","bumped":true,"bumped_at":"2021-12-27T17:00:37.699Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":7,"views":184,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":1304,"username":"lebrewer","name":"lebrewer","avatar_template":"/user_avatar/discourse.urho3d.io/lebrewer/{size}/2811_2.png"}}]},{"id":7120,"title":"Log Error Once Macro","fancy_title":"Log Error Once Macro","slug":"log-error-once-macro","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-01-04T02:24:37.857Z","last_posted_at":"2022-01-04T02:24:37.925Z","bumped":true,"bumped_at":"2022-01-04T02:24:37.925Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":3,"views":143,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}}]},{"id":7176,"title":"Orthographic scene slowing down when zooming out","fancy_title":"Orthographic scene slowing down when zooming out","slug":"orthographic-scene-slowing-down-when-zooming-out","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-01-30T10:05:50.218Z","last_posted_at":"2022-01-30T10:05:50.294Z","bumped":true,"bumped_at":"2022-01-30T10:05:50.294Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":127,"category_id":10,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":1351,"username":"Haukinger","name":"Haukinger","avatar_template":"/user_avatar/discourse.urho3d.io/haukinger/{size}/3670_2.png"}}]}],"tags_descriptions":{},"id":6115,"title":"UI Bezier Curve","fancy_title":"UI Bezier Curve","posts_count":1,"created_at":"2020-04-24T04:20:10.800Z","views":557,"reply_count":0,"like_count":3,"last_posted_at":"2020-04-24T04:20:10.940Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"ui-bezier-curve","category_id":13,"word_count":1956,"deleted_at":null,"user_id":628,"featured_link":null,"pinned_globally":false,"pinned_at":null,"pinned_until":null,"image_url":null,"slow_mode_seconds":0,"draft":null,"draft_key":"topic_6115","draft_sequence":null,"unpinned":null,"pinned":false,"current_post_number":1,"highest_post_number":1,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":false,"bookmarks":[],"topic_timer":null,"message_bus_last_id":0,"participant_count":1,"show_read_indicator":false,"thumbnails":null,"slow_mode_enabled_until":null,"tags_disable_ads":false,"details":{"can_edit":false,"notification_level":1,"participants":[{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png","post_count":1,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2}],"created_by":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"},"last_poster":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}}}