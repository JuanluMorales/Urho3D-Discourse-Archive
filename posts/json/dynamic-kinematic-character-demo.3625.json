{"post_stream":{"posts":[{"id":21086,"name":"","username":"ext1","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/e/f9ae1b/{size}.png","created_at":"2017-10-02T04:57:48.216Z","cooked":"\u003cp\u003eHello,\u003c/p\u003e\n\u003cp\u003eWhile exploring the \u003ca href=\"https://github.com/urho3d/Urho3D/tree/master/Source/Samples/18_CharacterDemo\" rel=\"nofollow noopener\"\u003eCharacter Demo\u003c/a\u003e I’ve ended up wanting a more “kinematic” movement (specially going up/down slopes), similar to raycast movement, but without losing the benefits of the dynamic character controller, the collision detection and physics overall.\u003c/p\u003e\n\u003cp\u003eAfter a lot of trial and error, I’ve managed to tinker the Character Demo and got pretty interesting results. The character no longer \u003ca href=\"https://discourse.urho3d.io/t/down-hill-movement-on-the-physics-simulation/3612\"\u003ebounces\u003c/a\u003e when going up/down a slope, neither slide when stopped, while still being able to jump and react to physics as usual (so it still respects angles, e.g.: will not climb steep walls).\u003c/p\u003e\n\u003cp\u003eCode that was changed from the original Character Demo (from Urho3D version 1.7):\u003c/p\u003e\n\u003cp\u003eCharacter.h - Line 63.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//\n// Copyright (c) 2008-2017 the Urho3D project.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n#pragma once\n\n#include \u0026lt;Urho3D/Input/Controls.h\u0026gt;\n#include \u0026lt;Urho3D/Scene/LogicComponent.h\u0026gt;\n\nusing namespace Urho3D;\n\nconst int CTRL_FORWARD = 1;\nconst int CTRL_BACK = 2;\nconst int CTRL_LEFT = 4;\nconst int CTRL_RIGHT = 8;\nconst int CTRL_JUMP = 16;\n\nconst float MOVE_FORCE = 0.8f;\nconst float INAIR_MOVE_FORCE = 0.02f;\nconst float BRAKE_FORCE = 0.2f;\nconst float JUMP_FORCE = 7.0f;\nconst float YAW_SENSITIVITY = 0.1f;\nconst float INAIR_THRESHOLD_TIME = 0.1f;\n\n/// Character component, responsible for physical movement according to controls, as well as animation.\nclass Character : public LogicComponent\n{\n    URHO3D_OBJECT(Character, LogicComponent);\n\npublic:\n    /// Construct.\n    Character(Context* context);\n\n    /// Register object factory and attributes.\n    static void RegisterObject(Context* context);\n\n    /// Handle startup. Called by LogicComponent base class.\n    virtual void Start();\n    /// Handle physics world update. Called by LogicComponent base class.\n    virtual void FixedUpdate(float timeStep);\n\n    /// Movement controls. Assigned by the main program each frame.\n    Controls controls_;\n\n    /* Stores the floor normal from a raycast down on the character location. */\n    Vector3 floorNormal;\n\nprivate:\n    /// Handle physics collision event.\n    void HandleNodeCollision(StringHash eventType, VariantMap\u0026amp; eventData);\n\n    /// Grounded flag for movement.\n    bool onGround_;\n    /// Jump flag.\n    bool okToJump_;\n    /// In air timer. Due to possible physics inaccuracy, character can be off ground for max. 1/10 second and still be allowed to move.\n    float inAirTimer_;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCharacter.cpp - Lines 78, 80, 88, 90 and 146.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//\n// Copyright (c) 2008-2017 the Urho3D project.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n#include \u0026lt;Urho3D/Core/Context.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/AnimationController.h\u0026gt;\n#include \u0026lt;Urho3D/IO/MemoryBuffer.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/PhysicsEvents.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/PhysicsWorld.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/RigidBody.h\u0026gt;\n#include \u0026lt;Urho3D/Scene/Scene.h\u0026gt;\n#include \u0026lt;Urho3D/Scene/SceneEvents.h\u0026gt;\n\n#include \"Character.h\"\n\nCharacter::Character(Context* context) :\n    LogicComponent(context),\n    onGround_(false),\n    okToJump_(true),\n    inAirTimer_(0.0f)\n{\n    // Only the physics update event is needed: unsubscribe from the rest for optimization\n    SetUpdateEventMask(USE_FIXEDUPDATE);\n}\n\nvoid Character::RegisterObject(Context* context)\n{\n    context-\u0026gt;RegisterFactory\u0026lt;Character\u0026gt;();\n\n    // These macros register the class attributes to the Context for automatic load / save handling.\n    // We specify the Default attribute mode which means it will be used both for saving into file, and network replication\n    URHO3D_ATTRIBUTE(\"Controls Yaw\", float, controls_.yaw_, 0.0f, AM_DEFAULT);\n    URHO3D_ATTRIBUTE(\"Controls Pitch\", float, controls_.pitch_, 0.0f, AM_DEFAULT);\n    URHO3D_ATTRIBUTE(\"On Ground\", bool, onGround_, false, AM_DEFAULT);\n    URHO3D_ATTRIBUTE(\"OK To Jump\", bool, okToJump_, true, AM_DEFAULT);\n    URHO3D_ATTRIBUTE(\"In Air Timer\", float, inAirTimer_, 0.0f, AM_DEFAULT);\n}\n\nvoid Character::Start()\n{\n    // Component has been inserted into its scene node. Subscribe to events now\n    SubscribeToEvent(GetNode(), E_NODECOLLISION, URHO3D_HANDLER(Character, HandleNodeCollision));\n}\n\nvoid Character::FixedUpdate(float timeStep)\n{\n    /// \\todo Could cache the components for faster access instead of finding them each frame\n    RigidBody* body = GetComponent\u0026lt;RigidBody\u0026gt;();\n    AnimationController* animCtrl = node_-\u0026gt;GetComponent\u0026lt;AnimationController\u0026gt;(true);\n\n    // Update the in air timer. Reset if grounded\n    if (!onGround_)\n        inAirTimer_ += timeStep;\n    else\n        inAirTimer_ = 0.0f;\n    // When character has been in air less than 1/10 second, it's still interpreted as being on ground\n    bool softGrounded = inAirTimer_ \u0026lt; INAIR_THRESHOLD_TIME;\n\n    // Update movement \u0026amp; animation\n    //const Quaternion\u0026amp; rot = node_-\u0026gt;GetRotation(); /* Removed */\n\n    /* Calculate the floor angle with the floor normal and rotate the character with that angle so it can move on any direction and have vertical velocity. */\n    /* Based on 1vanK's post: https://discourse.urho3d.io/t/solved-how-to-direct-a-character-parallel-to-the-ground/1285/5 */\n    Quaternion floorAngle = Quaternion(Vector3(0.0f, 1.0f, 0.0f), floorNormal);\n    Quaternion rot = floorAngle * Quaternion(node_-\u0026gt;GetRotation());\n\n    Vector3 moveDir = Vector3::ZERO;\n    const Vector3\u0026amp; velocity = body-\u0026gt;GetLinearVelocity();\n    // Velocity on the XZ plane\n    // Vector3 planeVelocity(velocity.x_, 0.0f, velocity.z_); /* Removed */\n\n    /* Set the velocity on all directions so it can also have vertical velocity. */\n    /* Special thanks for Eugene for pointing vertical velocity and for Carnalis from helping figure out this problem. */\n    Vector3 planeVelocity(velocity);\n\n    if (controls_.IsDown(CTRL_FORWARD))\n        moveDir += Vector3::FORWARD;\n    if (controls_.IsDown(CTRL_BACK))\n        moveDir += Vector3::BACK;\n    if (controls_.IsDown(CTRL_LEFT))\n        moveDir += Vector3::LEFT;\n    if (controls_.IsDown(CTRL_RIGHT))\n        moveDir += Vector3::RIGHT;\n\n    // Normalize move vector so that diagonal strafing is not faster\n    if (moveDir.LengthSquared() \u0026gt; 0.0f)\n        moveDir.Normalize();\n\n    // If in air, allow control, but slower than when on ground\n    body-\u0026gt;ApplyImpulse(rot * moveDir * (softGrounded ? MOVE_FORCE : INAIR_MOVE_FORCE));\n\n    if (softGrounded)\n    {\n        // When on ground, apply a braking force to limit maximum ground velocity\n        Vector3 brakeForce = -planeVelocity * BRAKE_FORCE;\n        body-\u0026gt;ApplyImpulse(brakeForce);\n\n        // Jump. Must release jump control between jumps\n        if (controls_.IsDown(CTRL_JUMP))\n        {\n            if (okToJump_)\n            {\n                body-\u0026gt;ApplyImpulse(Vector3::UP * JUMP_FORCE);\n                okToJump_ = false;\n                animCtrl-\u0026gt;PlayExclusive(\"Models/Mutant/Mutant_Jump1.ani\", 0, false, 0.2f);\n            }\n        }\n        else\n            okToJump_ = true;\n    }\n\n    if ( !onGround_ )\n    {\n        animCtrl-\u0026gt;PlayExclusive(\"Models/Mutant/Mutant_Jump1.ani\", 0, false, 0.2f);\n    }\n    else\n    {\n        // Play walk animation if moving on ground, otherwise fade it out\n        if (softGrounded \u0026amp;\u0026amp; !moveDir.Equals(Vector3::ZERO))\n            animCtrl-\u0026gt;PlayExclusive(\"Models/Mutant/Mutant_Run.ani\", 0, true, 0.2f);\n        else\n            animCtrl-\u0026gt;PlayExclusive(\"Models/Mutant/Mutant_Idle0.ani\", 0, true, 0.2f);\n\n        // Set walk animation speed proportional to velocity\n        animCtrl-\u0026gt;SetSpeed(\"Models/Mutant/Mutant_Run.ani\", planeVelocity.Length() * 0.3f);\n    }\n\n    /* Stops the character from sliding down when not moving. */\n    /* From 1vanK's post: https://discourse.urho3d.io/t/improved-charactercontroller/3472 */\n    if ( softGrounded \u0026amp;\u0026amp; okToJump_ \u0026amp;\u0026amp; moveDir == Vector3::ZERO) {\n        body-\u0026gt;SetUseGravity(false);\n        body-\u0026gt;SetLinearVelocity(Vector3::ZERO);\n    } else {\n        body-\u0026gt;SetUseGravity(true);\n    }\n\n    // Reset grounded flag for next frame\n    onGround_ = false;\n}\n\nvoid Character::HandleNodeCollision(StringHash eventType, VariantMap\u0026amp; eventData)\n{\n    // Check collision contacts and see if character is standing on ground (look for a contact that has near vertical normal)\n    using namespace NodeCollision;\n\n    MemoryBuffer contacts(eventData[P_CONTACTS].GetBuffer());\n\n    while (!contacts.IsEof())\n    {\n        Vector3 contactPosition = contacts.ReadVector3();\n        Vector3 contactNormal = contacts.ReadVector3();\n        /*float contactDistance = */contacts.ReadFloat();\n        /*float contactImpulse = */contacts.ReadFloat();\n\n        // If contact is below node center and pointing up, assume it's a ground contact\n        if (contactPosition.y_ \u0026lt; (node_-\u0026gt;GetPosition().y_ + 1.0f))\n        {\n            float level = contactNormal.y_;\n            if (level \u0026gt; 0.75)\n                onGround_ = true;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCharacterDemo.cpp - Lines 129, 141 and 348.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//\n// Copyright (c) 2008-2017 the Urho3D project.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n//\n\n#include \u0026lt;Urho3D/Core/CoreEvents.h\u0026gt;\n#include \u0026lt;Urho3D/Core/ProcessUtils.h\u0026gt;\n#include \u0026lt;Urho3D/Engine/Engine.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/AnimatedModel.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/AnimationController.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Camera.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Light.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Material.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Octree.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Renderer.h\u0026gt;\n#include \u0026lt;Urho3D/Graphics/Zone.h\u0026gt;\n#include \u0026lt;Urho3D/Input/Controls.h\u0026gt;\n#include \u0026lt;Urho3D/Input/Input.h\u0026gt;\n#include \u0026lt;Urho3D/IO/FileSystem.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/CollisionShape.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/PhysicsWorld.h\u0026gt;\n#include \u0026lt;Urho3D/Physics/RigidBody.h\u0026gt;\n#include \u0026lt;Urho3D/Resource/ResourceCache.h\u0026gt;\n#include \u0026lt;Urho3D/Scene/Scene.h\u0026gt;\n#include \u0026lt;Urho3D/UI/Font.h\u0026gt;\n#include \u0026lt;Urho3D/UI/Text.h\u0026gt;\n#include \u0026lt;Urho3D/UI/UI.h\u0026gt;\n\n#include \"Character.h\"\n#include \"CharacterDemo.h\"\n#include \"Touch.h\"\n\n#include \u0026lt;Urho3D/DebugNew.h\u0026gt;\n\nURHO3D_DEFINE_APPLICATION_MAIN(CharacterDemo)\n\nCharacterDemo::CharacterDemo(Context* context) :\n    Sample(context),\n    firstPerson_(false)\n{\n    // Register factory and attributes for the Character component so it can be created via CreateComponent, and loaded / saved\n    Character::RegisterObject(context);\n}\n\nCharacterDemo::~CharacterDemo()\n{\n}\n\nvoid CharacterDemo::Start()\n{\n    // Execute base class startup\n    Sample::Start();\n    if (touchEnabled_)\n        touch_ = new Touch(context_, TOUCH_SENSITIVITY);\n\n    // Create static scene content\n    CreateScene();\n\n    // Create the controllable character\n    CreateCharacter();\n\n    // Create the UI content\n    CreateInstructions();\n\n    // Subscribe to necessary events\n    SubscribeToEvents();\n\n    // Set the mouse mode to use in the sample\n    Sample::InitMouseMode(MM_RELATIVE);\n}\n\nvoid CharacterDemo::CreateScene()\n{\n    ResourceCache* cache = GetSubsystem\u0026lt;ResourceCache\u0026gt;();\n\n    scene_ = new Scene(context_);\n\n    // Create scene subsystem components\n    scene_-\u0026gt;CreateComponent\u0026lt;Octree\u0026gt;();\n    scene_-\u0026gt;CreateComponent\u0026lt;PhysicsWorld\u0026gt;();\n\n    // Create camera and define viewport. We will be doing load / save, so it's convenient to create the camera outside the scene,\n    // so that it won't be destroyed and recreated, and we don't have to redefine the viewport on load\n    cameraNode_ = new Node(context_);\n    Camera* camera = cameraNode_-\u0026gt;CreateComponent\u0026lt;Camera\u0026gt;();\n    camera-\u0026gt;SetFarClip(300.0f);\n    GetSubsystem\u0026lt;Renderer\u0026gt;()-\u0026gt;SetViewport(0, new Viewport(context_, scene_, camera));\n\n    // Create static scene content. First create a zone for ambient lighting and fog control\n    Node* zoneNode = scene_-\u0026gt;CreateChild(\"Zone\");\n    Zone* zone = zoneNode-\u0026gt;CreateComponent\u0026lt;Zone\u0026gt;();\n    zone-\u0026gt;SetAmbientColor(Color(0.15f, 0.15f, 0.15f));\n    zone-\u0026gt;SetFogColor(Color(0.5f, 0.5f, 0.7f));\n    zone-\u0026gt;SetFogStart(100.0f);\n    zone-\u0026gt;SetFogEnd(300.0f);\n    zone-\u0026gt;SetBoundingBox(BoundingBox(-1000.0f, 1000.0f));\n\n    // Create a directional light with cascaded shadow mapping\n    Node* lightNode = scene_-\u0026gt;CreateChild(\"DirectionalLight\");\n    lightNode-\u0026gt;SetDirection(Vector3(0.3f, -0.5f, 0.425f));\n    Light* light = lightNode-\u0026gt;CreateComponent\u0026lt;Light\u0026gt;();\n    light-\u0026gt;SetLightType(LIGHT_DIRECTIONAL);\n    light-\u0026gt;SetCastShadows(true);\n    light-\u0026gt;SetShadowBias(BiasParameters(0.00025f, 0.5f));\n    light-\u0026gt;SetShadowCascade(CascadeParameters(10.0f, 50.0f, 200.0f, 0.0f, 0.8f));\n    light-\u0026gt;SetSpecularIntensity(0.5f);\n\n    // Create the floor object\n    Node* floorNode = scene_-\u0026gt;CreateChild(\"Floor\");\n    floorNode-\u0026gt;SetPosition(Vector3(0.0f, -0.5f, 0.0f));\n    floorNode-\u0026gt;SetScale(Vector3(200.0f, 1.0f, 200.0f));\n    floorNode-\u0026gt;SetRotation(Quaternion(-30.0f, 0.0f, 0.0f)); /* Rotate the floor to simulate a slope. */\n    StaticModel* object = floorNode-\u0026gt;CreateComponent\u0026lt;StaticModel\u0026gt;();\n    object-\u0026gt;SetModel(cache-\u0026gt;GetResource\u0026lt;Model\u0026gt;(\"Models/Box.mdl\"));\n    object-\u0026gt;SetMaterial(cache-\u0026gt;GetResource\u0026lt;Material\u0026gt;(\"Materials/Stone.xml\"));\n\n    RigidBody* body = floorNode-\u0026gt;CreateComponent\u0026lt;RigidBody\u0026gt;();\n    // Use collision layer bit 2 to mark world scenery. This is what we will raycast against to prevent camera from going\n    // inside geometry\n    body-\u0026gt;SetCollisionLayer(2);\n    CollisionShape* shape = floorNode-\u0026gt;CreateComponent\u0026lt;CollisionShape\u0026gt;();\n    shape-\u0026gt;SetBox(Vector3::ONE);\n\n    /* Removed the mushrooms and boxes to simplify the test. */\n\n    /*\n    // Create mushrooms of varying sizes\n    const unsigned NUM_MUSHROOMS = 60;\n    for (unsigned i = 0; i \u0026lt; NUM_MUSHROOMS; ++i)\n    {\n        Node* objectNode = scene_-\u0026gt;CreateChild(\"Mushroom\");\n        objectNode-\u0026gt;SetPosition(Vector3(Random(180.0f) - 90.0f, 0.0f, Random(180.0f) - 90.0f));\n        objectNode-\u0026gt;SetRotation(Quaternion(0.0f, Random(360.0f), 0.0f));\n        objectNode-\u0026gt;SetScale(2.0f + Random(5.0f));\n        StaticModel* object = objectNode-\u0026gt;CreateComponent\u0026lt;StaticModel\u0026gt;();\n        object-\u0026gt;SetModel(cache-\u0026gt;GetResource\u0026lt;Model\u0026gt;(\"Models/Mushroom.mdl\"));\n        object-\u0026gt;SetMaterial(cache-\u0026gt;GetResource\u0026lt;Material\u0026gt;(\"Materials/Mushroom.xml\"));\n        object-\u0026gt;SetCastShadows(true);\n\n        RigidBody* body = objectNode-\u0026gt;CreateComponent\u0026lt;RigidBody\u0026gt;();\n        body-\u0026gt;SetCollisionLayer(2);\n        CollisionShape* shape = objectNode-\u0026gt;CreateComponent\u0026lt;CollisionShape\u0026gt;();\n        shape-\u0026gt;SetTriangleMesh(object-\u0026gt;GetModel(), 0);\n    }\n\n    // Create movable boxes. Let them fall from the sky at first\n    const unsigned NUM_BOXES = 100;\n    for (unsigned i = 0; i \u0026lt; NUM_BOXES; ++i)\n    {\n        float scale = Random(2.0f) + 0.5f;\n\n        Node* objectNode = scene_-\u0026gt;CreateChild(\"Box\");\n        objectNode-\u0026gt;SetPosition(Vector3(Random(180.0f) - 90.0f, Random(10.0f) + 10.0f, Random(180.0f) - 90.0f));\n        objectNode-\u0026gt;SetRotation(Quaternion(Random(360.0f), Random(360.0f), Random(360.0f)));\n        objectNode-\u0026gt;SetScale(scale);\n        StaticModel* object = objectNode-\u0026gt;CreateComponent\u0026lt;StaticModel\u0026gt;();\n        object-\u0026gt;SetModel(cache-\u0026gt;GetResource\u0026lt;Model\u0026gt;(\"Models/Box.mdl\"));\n        object-\u0026gt;SetMaterial(cache-\u0026gt;GetResource\u0026lt;Material\u0026gt;(\"Materials/Stone.xml\"));\n        object-\u0026gt;SetCastShadows(true);\n\n        RigidBody* body = objectNode-\u0026gt;CreateComponent\u0026lt;RigidBody\u0026gt;();\n        body-\u0026gt;SetCollisionLayer(2);\n        // Bigger boxes will be heavier and harder to move\n        body-\u0026gt;SetMass(scale * 2.0f);\n        CollisionShape* shape = objectNode-\u0026gt;CreateComponent\u0026lt;CollisionShape\u0026gt;();\n        shape-\u0026gt;SetBox(Vector3::ONE);\n    }\n    */\n\n}\n\nvoid CharacterDemo::CreateCharacter()\n{\n    ResourceCache* cache = GetSubsystem\u0026lt;ResourceCache\u0026gt;();\n\n    Node* objectNode = scene_-\u0026gt;CreateChild(\"Jack\");\n    objectNode-\u0026gt;SetPosition(Vector3(0.0f, 1.0f, 0.0f));\n\n    // spin node\n    Node* adjustNode = objectNode-\u0026gt;CreateChild(\"AdjNode\");\n    adjustNode-\u0026gt;SetRotation( Quaternion(180, Vector3(0,1,0) ) );\n\n    // Create the rendering component + animation controller\n    AnimatedModel* object = adjustNode-\u0026gt;CreateComponent\u0026lt;AnimatedModel\u0026gt;();\n    object-\u0026gt;SetModel(cache-\u0026gt;GetResource\u0026lt;Model\u0026gt;(\"Models/Mutant/Mutant.mdl\"));\n    object-\u0026gt;SetMaterial(cache-\u0026gt;GetResource\u0026lt;Material\u0026gt;(\"Models/Mutant/Materials/mutant_M.xml\"));\n    object-\u0026gt;SetCastShadows(true);\n    adjustNode-\u0026gt;CreateComponent\u0026lt;AnimationController\u0026gt;();\n\n    // Set the head bone for manual control\n    object-\u0026gt;GetSkeleton().GetBone(\"Mutant:Head\")-\u0026gt;animated_ = false;\n\n    // Create rigidbody, and set non-zero mass so that the body becomes dynamic\n    RigidBody* body = objectNode-\u0026gt;CreateComponent\u0026lt;RigidBody\u0026gt;();\n    body-\u0026gt;SetCollisionLayer(1);\n    body-\u0026gt;SetMass(1.0f);\n\n    // Set zero angular factor so that physics doesn't turn the character on its own.\n    // Instead we will control the character yaw manually\n    body-\u0026gt;SetAngularFactor(Vector3::ZERO);\n\n    // Set the rigidbody to signal collision also when in rest, so that we get ground collisions properly\n    body-\u0026gt;SetCollisionEventMode(COLLISION_ALWAYS);\n\n    // Set a capsule shape for collision\n    CollisionShape* shape = objectNode-\u0026gt;CreateComponent\u0026lt;CollisionShape\u0026gt;();\n    shape-\u0026gt;SetCapsule(0.7f, 1.8f, Vector3(0.0f, 0.9f, 0.0f));\n\n    // Create the character logic component, which takes care of steering the rigidbody\n    // Remember it so that we can set the controls. Use a WeakPtr because the scene hierarchy already owns it\n    // and keeps it alive as long as it's not removed from the hierarchy\n    character_ = objectNode-\u0026gt;CreateComponent\u0026lt;Character\u0026gt;();\n}\n\nvoid CharacterDemo::CreateInstructions()\n{\n    ResourceCache* cache = GetSubsystem\u0026lt;ResourceCache\u0026gt;();\n    UI* ui = GetSubsystem\u0026lt;UI\u0026gt;();\n\n    // Construct new Text object, set string to display and font to use\n    Text* instructionText = ui-\u0026gt;GetRoot()-\u0026gt;CreateChild\u0026lt;Text\u0026gt;();\n    instructionText-\u0026gt;SetText(\n        \"Use WASD keys and mouse/touch to move\\n\"\n        \"Space to jump, F to toggle 1st/3rd person\\n\"\n        \"F5 to save scene, F7 to load\"\n    );\n    instructionText-\u0026gt;SetFont(cache-\u0026gt;GetResource\u0026lt;Font\u0026gt;(\"Fonts/Anonymous Pro.ttf\"), 15);\n    // The text has multiple rows. Center them in relation to each other\n    instructionText-\u0026gt;SetTextAlignment(HA_CENTER);\n\n    // Position the text relative to the screen center\n    instructionText-\u0026gt;SetHorizontalAlignment(HA_CENTER);\n    instructionText-\u0026gt;SetVerticalAlignment(VA_CENTER);\n    instructionText-\u0026gt;SetPosition(0, ui-\u0026gt;GetRoot()-\u0026gt;GetHeight() / 4);\n}\n\nvoid CharacterDemo::SubscribeToEvents()\n{\n    // Subscribe to Update event for setting the character controls before physics simulation\n    SubscribeToEvent(E_UPDATE, URHO3D_HANDLER(CharacterDemo, HandleUpdate));\n\n    // Subscribe to PostUpdate event for updating the camera position after physics simulation\n    SubscribeToEvent(E_POSTUPDATE, URHO3D_HANDLER(CharacterDemo, HandlePostUpdate));\n\n    // Unsubscribe the SceneUpdate event from base class as the camera node is being controlled in HandlePostUpdate() in this sample\n    UnsubscribeFromEvent(E_SCENEUPDATE);\n}\n\nvoid CharacterDemo::HandleUpdate(StringHash eventType, VariantMap\u0026amp; eventData)\n{\n    using namespace Update;\n\n    Input* input = GetSubsystem\u0026lt;Input\u0026gt;();\n\n    if (character_)\n    {\n        // Clear previous controls\n        character_-\u0026gt;controls_.Set(CTRL_FORWARD | CTRL_BACK | CTRL_LEFT | CTRL_RIGHT | CTRL_JUMP, false);\n\n        // Update controls using touch utility class\n        if (touch_)\n            touch_-\u0026gt;UpdateTouches(character_-\u0026gt;controls_);\n\n        // Update controls using keys\n        UI* ui = GetSubsystem\u0026lt;UI\u0026gt;();\n        if (!ui-\u0026gt;GetFocusElement())\n        {\n            if (!touch_ || !touch_-\u0026gt;useGyroscope_)\n            {\n                character_-\u0026gt;controls_.Set(CTRL_FORWARD, input-\u0026gt;GetKeyDown(KEY_W));\n                character_-\u0026gt;controls_.Set(CTRL_BACK, input-\u0026gt;GetKeyDown(KEY_S));\n                character_-\u0026gt;controls_.Set(CTRL_LEFT, input-\u0026gt;GetKeyDown(KEY_A));\n                character_-\u0026gt;controls_.Set(CTRL_RIGHT, input-\u0026gt;GetKeyDown(KEY_D));\n            }\n            character_-\u0026gt;controls_.Set(CTRL_JUMP, input-\u0026gt;GetKeyDown(KEY_SPACE));\n\n            // Add character yaw \u0026amp; pitch from the mouse motion or touch input\n            if (touchEnabled_)\n            {\n                for (unsigned i = 0; i \u0026lt; input-\u0026gt;GetNumTouches(); ++i)\n                {\n                    TouchState* state = input-\u0026gt;GetTouch(i);\n                    if (!state-\u0026gt;touchedElement_)    // Touch on empty space\n                    {\n                        Camera* camera = cameraNode_-\u0026gt;GetComponent\u0026lt;Camera\u0026gt;();\n                        if (!camera)\n                            return;\n\n                        Graphics* graphics = GetSubsystem\u0026lt;Graphics\u0026gt;();\n                        character_-\u0026gt;controls_.yaw_ += TOUCH_SENSITIVITY * camera-\u0026gt;GetFov() / graphics-\u0026gt;GetHeight() * state-\u0026gt;delta_.x_;\n                        character_-\u0026gt;controls_.pitch_ += TOUCH_SENSITIVITY * camera-\u0026gt;GetFov() / graphics-\u0026gt;GetHeight() * state-\u0026gt;delta_.y_;\n                    }\n                }\n            }\n            else\n            {\n                character_-\u0026gt;controls_.yaw_ += (float)input-\u0026gt;GetMouseMoveX() * YAW_SENSITIVITY;\n                character_-\u0026gt;controls_.pitch_ += (float)input-\u0026gt;GetMouseMoveY() * YAW_SENSITIVITY;\n            }\n            // Limit pitch\n            character_-\u0026gt;controls_.pitch_ = Clamp(character_-\u0026gt;controls_.pitch_, -80.0f, 80.0f);\n            // Set rotation already here so that it's updated every rendering frame instead of every physics frame\n            character_-\u0026gt;GetNode()-\u0026gt;SetRotation(Quaternion(character_-\u0026gt;controls_.yaw_, Vector3::UP));\n\n            // Switch between 1st and 3rd person\n            if (input-\u0026gt;GetKeyPress(KEY_F))\n                firstPerson_ = !firstPerson_;\n\n            // Turn on/off gyroscope on mobile platform\n            if (touch_ \u0026amp;\u0026amp; input-\u0026gt;GetKeyPress(KEY_G))\n                touch_-\u0026gt;useGyroscope_ = !touch_-\u0026gt;useGyroscope_;\n\n            // Check for loading / saving the scene\n            if (input-\u0026gt;GetKeyPress(KEY_F5))\n            {\n                File saveFile(context_, GetSubsystem\u0026lt;FileSystem\u0026gt;()-\u0026gt;GetProgramDir() + \"Data/Scenes/CharacterDemo.xml\", FILE_WRITE);\n                scene_-\u0026gt;SaveXML(saveFile);\n            }\n            if (input-\u0026gt;GetKeyPress(KEY_F7))\n            {\n                File loadFile(context_, GetSubsystem\u0026lt;FileSystem\u0026gt;()-\u0026gt;GetProgramDir() + \"Data/Scenes/CharacterDemo.xml\", FILE_READ);\n                scene_-\u0026gt;LoadXML(loadFile);\n                // After loading we have to reacquire the weak pointer to the Character component, as it has been recreated\n                // Simply find the character's scene node by name as there's only one of them\n                Node* characterNode = scene_-\u0026gt;GetChild(\"Jack\", true);\n                if (characterNode)\n                    character_ = characterNode-\u0026gt;GetComponent\u0026lt;Character\u0026gt;();\n            }\n        }\n\n        /* Raycast down to get the floor normal under the character and store the normal value. */\n        PhysicsRaycastResult result;\n        scene_-\u0026gt;GetComponent\u0026lt;PhysicsWorld\u0026gt;()-\u0026gt;RaycastSingle(result, Ray( character_-\u0026gt;GetNode()-\u0026gt;GetPosition() , Vector3(0.0f,-1.0f,0.0f) ), 5.0f, 2);\n        if (result.body_) {\n            character_-\u0026gt;floorNormal=result.normal_;\n        }\n\n    }\n}\n\nvoid CharacterDemo::HandlePostUpdate(StringHash eventType, VariantMap\u0026amp; eventData)\n{\n    if (!character_)\n        return;\n\n    Node* characterNode = character_-\u0026gt;GetNode();\n\n    // Get camera lookat dir from character yaw + pitch\n    Quaternion rot = characterNode-\u0026gt;GetRotation();\n    Quaternion dir = rot * Quaternion(character_-\u0026gt;controls_.pitch_, Vector3::RIGHT);\n\n    // Turn head to camera pitch, but limit to avoid unnatural animation\n    Node* headNode = characterNode-\u0026gt;GetChild(\"Mutant:Head\", true);\n    float limitPitch = Clamp(character_-\u0026gt;controls_.pitch_, -45.0f, 45.0f);\n    Quaternion headDir = rot * Quaternion(limitPitch, Vector3(1.0f, 0.0f, 0.0f));\n    // This could be expanded to look at an arbitrary target, now just look at a point in front\n    Vector3 headWorldTarget = headNode-\u0026gt;GetWorldPosition() + headDir * Vector3(0.0f, 0.0f, -1.0f);\n    headNode-\u0026gt;LookAt(headWorldTarget, Vector3(0.0f, 1.0f, 0.0f));\n\n    if (firstPerson_)\n    {\n        cameraNode_-\u0026gt;SetPosition(headNode-\u0026gt;GetWorldPosition() + rot * Vector3(0.0f, 0.15f, 0.2f));\n        cameraNode_-\u0026gt;SetRotation(dir);\n    }\n    else\n    {\n        // Third person camera: position behind the character\n        Vector3 aimPoint = characterNode-\u0026gt;GetPosition() + rot * Vector3(0.0f, 1.7f, 0.0f);\n\n        // Collide camera ray with static physics objects (layer bitmask 2) to ensure we see the character properly\n        Vector3 rayDir = dir * Vector3::BACK;\n        float rayDistance = touch_ ? touch_-\u0026gt;cameraDistance_ : CAMERA_INITIAL_DIST;\n        PhysicsRaycastResult result;\n        scene_-\u0026gt;GetComponent\u0026lt;PhysicsWorld\u0026gt;()-\u0026gt;RaycastSingle(result, Ray(aimPoint, rayDir), rayDistance, 2);\n        if (result.body_)\n            rayDistance = Min(rayDistance, result.distance_);\n        rayDistance = Clamp(rayDistance, CAMERA_MIN_DIST, CAMERA_MAX_DIST);\n\n        cameraNode_-\u0026gt;SetPosition(aimPoint + rayDir * rayDistance);\n        cameraNode_-\u0026gt;SetRotation(dir);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSpecial thanks to \u003ca class=\"mention\" href=\"/u/1vank\"\u003e@1vanK\u003c/a\u003e, his posts \u003ca href=\"https://discourse.urho3d.io/t/solved-how-to-direct-a-character-parallel-to-the-ground/1285/5\"\u003eHow to direct a character parallel to the ground?\u003c/a\u003e and \u003ca href=\"https://discourse.urho3d.io/t/improved-charactercontroller/3472\"\u003eImproved CharacterController\u003c/a\u003e were essential to fix the movement.\u003c/p\u003e\n\u003cp\u003eAlso special thanks to \u003ca class=\"mention\" href=\"/u/eugene\"\u003e@Eugene\u003c/a\u003e for pointing vertical velocity and to \u003ca class=\"mention\" href=\"/u/jmiller\"\u003e@jmiller\u003c/a\u003e for taking the time to help figure out this problem. You guys are awesome!\u003c/p\u003e\n\u003cp\u003eBest regards.\u003c/p\u003e","post_number":1,"post_type":1,"updated_at":"2017-10-09T02:48:19.522Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":151,"reads":103,"readers_count":102,"score":931.6,"yours":false,"topic_id":3625,"topic_slug":"dynamic-kinematic-character-demo","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":4,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"https://github.com/urho3d/Urho3D/tree/master/Source/Samples/18_CharacterDemo","internal":false,"reflection":false,"title":"Urho3D/Source/Samples/18_CharacterDemo at master · urho3d/Urho3D · GitHub","clicks":35},{"url":"http://discourse.urho3d.io/t/improved-charactercontroller/3472","internal":true,"reflection":false,"title":"Improved CharacterController","clicks":24},{"url":"http://discourse.urho3d.io/t/down-hill-movement-on-the-physics-simulation/3612","internal":true,"reflection":false,"title":"Down hill movement on the physics simulation","clicks":9},{"url":"http://discourse.urho3d.io/t/how-to-direct-a-character-parallel-to-the-ground/1285/5","internal":true,"reflection":false,"title":"How to direct a character parallel to the ground?","clicks":0},{"url":"https://discourse.urho3d.io/t/a-more-advanced-character-controller/5052/2","internal":true,"reflection":true,"title":"A more advanced character controller","clicks":1}],"read":true,"user_title":null,"bookmarked":false,"actions_summary":[{"id":2,"count":5}],"moderator":false,"admin":false,"staff":false,"user_id":838,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":22747,"name":"Eugene Kozlov","username":"Eugene","avatar_template":"/user_avatar/discourse.urho3d.io/eugene/{size}/902_2.png","created_at":"2018-01-04T21:07:27.097Z","cooked":"\u003cp\u003e(just wanted to mention it somewhere)\u003cbr\u003e\nThere is another approach of implementing character controller: use \u003ccode\u003eCrowdAgent\u003c/code\u003e.\u003cbr\u003e\nThen set \u003ccode\u003eweightToi\u003c/code\u003e to some small value and use \u003ccode\u003eSetTargetVelocity\u003c/code\u003e to drive character.\u003c/p\u003e\n\u003cp\u003eIt could be used almost without tweaks if character doesn’t jump and moves over static geometry only.\u003cbr\u003e\nThere may be some tricks to use this approach for generic character controller tho…\u003c/p\u003e\n\u003cp\u003eI wanted to mention it because tweaking \u003ccode\u003eweightToi\u003c/code\u003e is not obvious at all.\u003c/p\u003e","post_number":2,"post_type":1,"updated_at":"2018-01-04T21:08:26.962Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":78,"readers_count":77,"score":75.6,"yours":false,"topic_id":3625,"topic_slug":"dynamic-kinematic-character-demo","display_username":"Eugene Kozlov","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":"Core developer","title_is_group":false,"bookmarked":false,"actions_summary":[{"id":2,"count":2}],"moderator":false,"admin":false,"staff":false,"user_id":484,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":29525,"name":"QB'k Games","username":"QBkGames","avatar_template":"/user_avatar/discourse.urho3d.io/qbkgames/{size}/646_2.png","created_at":"2019-04-28T00:54:59.942Z","cooked":"\u003cp\u003eI’ve learned the hard way that HandleNodeCollision algorithm can get stuck in valleys between 2 (or more) slopes and the character will never become grounded.\u003cbr\u003e\nA better way would be to average all the contact normals and check if the average.y_ \u0026gt; 0.75 to determined if the character is grounded.\u003c/p\u003e\n\u003cp\u003eAlso simply disabling gravity risks having the character floating up and away if something else bumps into it.\u003c/p\u003e","post_number":3,"post_type":1,"updated_at":"2019-04-28T00:54:59.942Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":41,"readers_count":40,"score":8.2,"yours":false,"topic_id":3625,"topic_slug":"dynamic-kinematic-character-demo","display_username":"QB'k Games","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":780,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false}],"stream":[21086,22747,29525]},"timeline_lookup":[[1,1878],[2,1783],[3,1305]],"suggested_topics":[{"id":7120,"title":"Log Error Once Macro","fancy_title":"Log Error Once Macro","slug":"log-error-once-macro","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-01-04T02:24:37.857Z","last_posted_at":"2022-01-04T02:24:37.925Z","bumped":true,"bumped_at":"2022-01-04T02:24:37.925Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":3,"views":143,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}}]},{"id":7099,"title":":fallen_leaf: Polynomials \u0026 Harmonics","fancy_title":":fallen_leaf: Polynomials \u0026amp; Harmonics","slug":"polynomials-harmonics","posts_count":6,"reply_count":0,"highest_post_number":7,"image_url":null,"created_at":"2021-12-13T05:06:04.641Z","last_posted_at":"2021-12-27T23:27:39.489Z","bumped":true,"bumped_at":"2021-12-27T23:27:39.489Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"unicode_title":"🍂 Polynomials \u0026 Harmonics","tags_descriptions":{},"like_count":6,"views":392,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}}]},{"id":7103,"title":":test_tube: DebugRenderer as GUI","fancy_title":":test_tube: DebugRenderer as GUI","slug":"debugrenderer-as-gui","posts_count":4,"reply_count":1,"highest_post_number":4,"image_url":null,"created_at":"2021-12-17T02:25:06.606Z","last_posted_at":"2021-12-18T01:09:27.738Z","bumped":true,"bumped_at":"2021-12-18T01:09:27.738Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"unicode_title":"🧪 DebugRenderer as GUI","tags_descriptions":{},"like_count":4,"views":267,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":861,"username":"GodMan","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/g/e79b87/{size}.png"}}]},{"id":7110,"title":"Resource fetch define","fancy_title":"Resource fetch define","slug":"resource-fetch-define","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2021-12-27T12:28:55.126Z","last_posted_at":"2021-12-27T17:00:37.699Z","bumped":true,"bumped_at":"2021-12-27T17:00:37.699Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":7,"views":184,"category_id":13,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":1304,"username":"lebrewer","name":"lebrewer","avatar_template":"/user_avatar/discourse.urho3d.io/lebrewer/{size}/2811_2.png"}}]},{"id":7092,"title":"Finding the World Space Coordinates of the Screen Edges","fancy_title":"Finding the World Space Coordinates of the Screen Edges","slug":"finding-the-world-space-coordinates-of-the-screen-edges","posts_count":6,"reply_count":2,"highest_post_number":6,"image_url":null,"created_at":"2021-12-07T20:53:49.453Z","last_posted_at":"2021-12-08T12:33:52.510Z","bumped":true,"bumped_at":"2021-12-08T12:33:52.510Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":210,"category_id":10,"featured_link":null,"has_accepted_answer":true,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster, Accepted Answer","user":{"id":1456,"username":"Jens","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/j/d2c977/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":192,"username":"Modanung","name":"魔大农 𝞍𝞎𝝳 現招蜍","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":263,"username":"1vanK","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/1vank/{size}/768_2.png"}}]}],"tags_descriptions":{},"id":3625,"title":"Dynamic \"Kinematic\" Character Demo","fancy_title":"Dynamic \u0026ldquo;Kinematic\u0026rdquo; Character Demo","posts_count":3,"created_at":"2017-10-02T04:57:48.131Z","views":1802,"reply_count":0,"like_count":7,"last_posted_at":"2019-04-28T00:54:59.942Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"dynamic-kinematic-character-demo","category_id":13,"word_count":3472,"deleted_at":null,"user_id":838,"featured_link":null,"pinned_globally":false,"pinned_at":null,"pinned_until":null,"image_url":null,"slow_mode_seconds":0,"draft":null,"draft_key":"topic_3625","draft_sequence":null,"unpinned":null,"pinned":false,"current_post_number":1,"highest_post_number":3,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":false,"bookmarks":[],"topic_timer":null,"message_bus_last_id":0,"participant_count":3,"show_read_indicator":false,"thumbnails":null,"slow_mode_enabled_until":null,"tags_disable_ads":false,"details":{"can_edit":false,"notification_level":1,"participants":[{"id":484,"username":"Eugene","name":"Eugene Kozlov","avatar_template":"/user_avatar/discourse.urho3d.io/eugene/{size}/902_2.png","post_count":1,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2},{"id":780,"username":"QBkGames","name":"QB'k Games","avatar_template":"/user_avatar/discourse.urho3d.io/qbkgames/{size}/646_2.png","post_count":1,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2},{"id":838,"username":"ext1","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/e/f9ae1b/{size}.png","post_count":1,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2}],"created_by":{"id":838,"username":"ext1","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/e/f9ae1b/{size}.png"},"last_poster":{"id":780,"username":"QBkGames","name":"QB'k Games","avatar_template":"/user_avatar/discourse.urho3d.io/qbkgames/{size}/646_2.png"},"links":[{"url":"https://github.com/urho3d/Urho3D/tree/master/Source/Samples/18_CharacterDemo","title":"Urho3D/Source/Samples/18_CharacterDemo at master · urho3d/Urho3D · GitHub","internal":false,"attachment":false,"reflection":false,"clicks":35,"user_id":838,"domain":"github.com","root_domain":"github.com"},{"url":"http://discourse.urho3d.io/t/improved-charactercontroller/3472","title":"Improved CharacterController","internal":true,"attachment":false,"reflection":false,"clicks":24,"user_id":838,"domain":"discourse.urho3d.io","root_domain":"urho3d.io"},{"url":"http://discourse.urho3d.io/t/down-hill-movement-on-the-physics-simulation/3612","title":"Down hill movement on the physics simulation","internal":true,"attachment":false,"reflection":false,"clicks":9,"user_id":838,"domain":"discourse.urho3d.io","root_domain":"urho3d.io"},{"url":"https://discourse.urho3d.io/t/a-more-advanced-character-controller/5052/2","title":"A more advanced character controller","internal":true,"attachment":false,"reflection":true,"clicks":1,"user_id":674,"domain":"discourse.urho3d.io","root_domain":"urho3d.io"}]}}