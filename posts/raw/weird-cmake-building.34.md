NemesisFS | 2017-01-02 00:57:31 UTC | #1

Hi,

I just started to try to use Urho3D and noticed that the build process is pretty odd compared to other projects. Wouldnt it be nicer to have a standard CMakeLists.txt which generates a Urho3DConfig.cmake which one can use in a project? Why does Urho3D use custom scripts for different targets and a 700-line "magic" script?

Also I noticed that some conventions are broken in the FindUrho3D.cmake as it does not use URHO3D_INCLUDE_DIRS and instead uses URHO3D_INCLUDE_DIR...

I`m not that used to bigger projects so I just wanted to ask what the reasons are for this non-standard CMake usage...

-------------------------

cadaver | 2017-01-02 00:57:31 UTC | #2

The point is that both the library itself and programs using it need the same "magic" setup, and there should be nothing that is specified in two places in cmake script to avoid maintenance problems. Maybe if the Urho3DConfig.cmake could be autogenerated from the Urho3D-CMake-Magic? But weitjong will know better.

EDIT: worded in friendlier way :slight_smile:

-------------------------

weitjong | 2017-01-02 00:57:32 UTC | #3

Thanks for your valuable feedback. First, let me set this straight before attempting to answer your question. The current build scripts are not perfect yet and have rooms for improvement. As Urho3D project now attracts more and more talented peoples, you or anyone with CMake expertise are welcome to contribute to improve them. Our CMake build scripts have come a long way through slow incremental changes rather than one big revamp to where they are today and they should continue to change. There was a time "Urho3D" does not even exist as a CMake library target in the project.

Now, I will try to answer your questions:

[ul]
[li][b]URHO3D_INCLUDE_DIRS vs URHO3D_INCLUDE_DIR[/b]
By sheer luck when I wrote the first FindXXX CMake module for the project, I was following a bad template. The unconventional variable name unfortunately stays and spreads. I will correct this but this will break downstream projects using Urho3D as external library.

[/li]
[li][b]Urho3D-CMake-magic module[/b]
The module was created soon after we have created the "Urho3D" library target and for the first time we have the context of "library user". The module came to its being as an afterthought and as a response to a quick discussion in the former Urho3D forum quite similar to this discussion. Its goal is to share those reusable macros to library users. Those macros were in the main Urho3D project locked away from library user otherwise. Those 700-line script should always be there whether we chose to share it to downstream projects or not. It may not the best or conventional way to do it but it was the quickest way to get it done with the least impact to the rest of the build scripts at that time.

There is nothing "magical" about it. I wonder how many developers out there would stop for a few minutes like myself just to find a good name for their creation (and learn to regret the chosen name later  :slight_smile: ). Anyway, it was named after "magic" because of someone's comment in the forum back then (hint: it was quite similar to the comment above).

[/li]
[li][b]FindUrho3D module[/b]
Granted, the whole setup is a little unorthodox but it gets the job done for all the use cases for FindUrho3D module in all the supported platforms. It can be used both internally by Urho3D project and externally by downstream projects. It can be used with Urho3D installed or just in its own build tree, although at the moment it does not use any of CMake "export" and "import" commands. I chose not to use them simply because I have not yet seen the need of them. Having said that, please do not get me wrong here, I am simply explaining the rationale behind it and not trying to defend it. If someone knows better way to achieve the goal then please do share and contribute it to the project.[/li][/ul]

-------------------------

NemesisFS | 2017-01-02 00:57:32 UTC | #4

Thank you for taking the time to answer my question.
I already guessed that those were the reasons why the CMake setup is as it is, I was just wondering if there might be something I was overlooking as I lack the experience in CMake.

When I continue to use Urho3D and have something that might improve it I will share my code.

-------------------------

theslimde | 2017-01-02 00:57:33 UTC | #5

I would second a request for a regular CMake building, without this kind of black sorcery.

Also, I think you should expose the options in the CMake menu, it took me quite a while to figure
out i need -DENABLE_64BIT=1 to build on a 64 bit system.

-------------------------

friesencr | 2017-01-02 00:57:33 UTC | #6

The options are in the readme but it is towards the bottom.  I have had some issues with needing a 64 bit build.  I understand multiarch very well.  We can make mention of multiarch in the readme.

Is there anything wrong with just using the shell scripts for initializing cmake?  I feel very well taken care of by just following the conventions provided.  There is even instructions on how to add your own project to the build setup.

-------------------------

NemesisFS | 2017-01-02 00:57:33 UTC | #7

I just prefer to go with the standard when it comes to something like building. 
But I`ve got it working for me now, I just use the FindUrho3D.cmake and provide the path to the Urho3D project. I needed to include the Pthread, dl and OpenGL library manually but now I have my own CMakeLists which just includes a dependency.

-------------------------

NemesisFS | 2017-01-02 00:57:44 UTC | #8

Something I just recognized, in the current setup (at least for gcc) CMake doesnt recognize a changed cmake file and wont update the Build-directory accordingly.

-------------------------

weitjong | 2017-01-02 00:57:49 UTC | #9

[quote="NemesisFS"]Something I just recognized, in the current setup (at least for gcc) CMake doesnt recognize a changed cmake file and wont update the Build-directory accordingly.[/quote]

I beg to differ. During development of CMake build scripts where I often have to test the changes in my main Fedora (GCC) system and then on the other two test build VMs: Mac OS X (Xcode) and Win7 (MSVC), I only need to invoke "make all" (or ?+B or F7 on the respective VMs) and the changes in CMakeLists.txt are usually detected and applied directly before the build starts. The only exceptions where I find this does not work are:
[ol]
[li] when I need to change the build options[/li]
[li] when there are new source files being added into the project[/li][/ol]

-------------------------

NemesisFS | 2017-01-02 00:57:50 UTC | #10

Okay, then it might have been a flaw in my setup. after a pull building worked only after I invoked the gcc script again.

-------------------------

