{"post_stream":{"posts":[{"id":30112,"name":"Leith Ketchell","username":"Leith","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png","created_at":"2019-06-05T04:18:37.392Z","cooked":"\u003cp\u003eHey guys,\u003cbr\u003e\nlooking for some comments/opinions/criticism on the following:\u003c/p\u003e\n\u003cp\u003eI’ve got a character controller which is based on Bullet’s btKinematicCharacterController.\u003cbr\u003e\nInternally, the Bullet class uses a btPairCachingGhostObject to provide the character’s outer physics capsule. Unfortunately for me, Urho3D has no wrapper for GhostObjects, and Urho’s PhysicsWorld class does not provide collision events where ghost objects are concerned.\u003cbr\u003e\nIt is worth noting that Ghost Objects are NOT the same thing as trigger volumes (which Urho does support). The distinction between them is subtle, but we can definitely say that btPairCachingGhostObject is quite a different animal to btRigidBody.\u003c/p\u003e\n\u003cp\u003eIn order to remedy this, I began by defining some new Urho events:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003eURHO3D_EVENT(GHOST_COLLISION_STARTED, OnGhostCollisionBegin){\n    URHO3D_PARAM(P_BODY, Body);             /// RigidBody which collided with btGhostObject\n    URHO3D_PARAM(P_GHOST, Ghost);           /// btGhostObject which collided with RigidBody\n    URHO3D_PARAM(P_GHOSTNODE, GhostNode);   /// Scene node which acts as Parent to btGhostNode\n}\n\nURHO3D_EVENT(GHOST_COLLISION_STAY, OnGhostCollisionStay){\n    URHO3D_PARAM(P_BODY, Body);\n    URHO3D_PARAM(P_GHOST, Ghost);\n    URHO3D_PARAM(P_GHOSTNODE, GhostNode);\n}\n\nURHO3D_EVENT(GHOST_COLLISION_ENDED, OnGhostCollisionEnded){\n    URHO3D_PARAM(P_BODY, Body);\n    URHO3D_PARAM(P_GHOST, Ghost);\n    URHO3D_PARAM(P_GHOSTNODE, GhostNode);\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can see I chose not to provide contact information for ghost object collisions, and also I am only handling collisions between ghosts and rigidbodies (not ghosts and other ghosts).\u003c/p\u003e\n\u003cp\u003eI chose to track my collisions across frames in a simplified fashion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003eHashSet\u0026lt;WeakPtr\u0026lt;RigidBody\u0026gt;\u0026gt; prevCollisions;\nHashSet\u0026lt;WeakPtr\u0026lt;RigidBody\u0026gt;\u0026gt; currentCollisions;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally, here’s the code to deal with collision events for a single ghost object.\u003cbr\u003e\nI chose not to iterate the world collision manifolds, because the ghost object is already keeping track of a list of objects that it (potentially) collides with (since it represents a broadphase list of objects whose AABB are intersecting that of the ghost)…\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003e/// After physics update, move character root node to suit the physics\n/// We also deal with collision detection / event sourcing\nvoid KinematicCharacterController::HandlePostPhysicsUpdate(StringHash eventType, VariantMap\u0026amp; eventData){\n\n    if(ghostObject_){\n\n        currentCollisions.Clear();\n\n        /// Query the current world transform of the ghost object\n        btTransform t=ghostObject_-\u0026gt;getWorldTransform();\n\n        /// Teleport this character's parent node to suit the physics object\n        Vector3 worldPos = ToVector3(t.getOrigin()) + Vector3::DOWN * height_*0.5f;\n        node_-\u0026gt;SetWorldPosition( worldPos );\n\n\n        btManifoldArray manifoldArray;\n\n        /// Process all current collision events\n        /// (Ask ghost shape for a list of objects that it is potentially \"colliding\" with)\n        ///\n        int numObjects = ghostObject_-\u0026gt;getNumOverlappingObjects();\n        for(int i=0;i\u0026lt;numObjects;i++){\n\n\n            manifoldArray.clear();\n\n            /// Access the next collision object whose AABB overlaps with that of our ghost shape\n            btCollisionObject* obj = ghostObject_-\u0026gt;getOverlappingObject(i);\n\n            /// Try to cast the current collision object to bullet rigidbody\n            /// If this fails, its not a rigidbody - could be another ghost etc.\n            btRigidBody* rb = dynamic_cast\u0026lt;btRigidBody*\u0026gt;(obj);\n            if(rb){\n\n                /// Query the physics broadphase for deeper information about the colliding pair\n                auto* paircache = node_-\u0026gt;GetScene()-\u0026gt;GetComponent\u0026lt;PhysicsWorld\u0026gt;()-\u0026gt;GetWorld()-\u0026gt;getPairCache();\n                btBroadphasePair* collisionPair = paircache-\u0026gt;findPair(ghostObject_-\u0026gt;getBroadphaseHandle(), obj-\u0026gt;getBroadphaseHandle());\n                if (collisionPair == nullptr)\n                    continue;\n\n                /// Query the colliding pair for deeper information about the contact manifold(s)\n                if (collisionPair-\u0026gt;m_algorithm != nullptr)\n                    collisionPair-\u0026gt;m_algorithm-\u0026gt;getAllContactManifolds(manifoldArray);\n\n                if(manifoldArray.size()==0)\n                    continue;\n\n                /// Confirm that the two objects are in contact\n                int numContacts=0;\n                for(int i=0;i\u0026lt;manifoldArray.size();i++){\n                     btPersistentManifold* manifold = manifoldArray[i];\n                     numContacts += manifold-\u0026gt;getNumContacts();\n                }\n                if(numContacts==0)\n                  continue;\n\n                    /// Cast the bullet rigidbody userpointer to Urho RigidBody\n                    /// Dangerous assumption that this can never fail - hope springs eternal!\n                    RigidBody* RB = (RigidBody*)rb-\u0026gt;getUserPointer();\n\n                    /// Wrap the object pointer\n                    WeakPtr\u0026lt;RigidBody\u0026gt; weakRB(RB);\n\n                    VariantMap\u0026amp; newData = GetEventDataMap();\n\n                    /// Determine if this collision is \"new\", or \"persistant\"\n                    if(!prevCollisions.Contains(weakRB))\n                    {\n                        /// Send \"collision started\" event\n                        newData[OnGhostCollisionBegin::P_BODY] = RB;\n                        newData[OnGhostCollisionBegin::P_GHOST] = ghostObject_;\n                        newData[OnGhostCollisionBegin::P_GHOSTNODE] = node_;\n                        RB-\u0026gt;GetNode()-\u0026gt;SendEvent(GHOST_COLLISION_STARTED, newData);\n                        URHO3D_LOGINFO( RB-\u0026gt;GetNode()-\u0026gt;GetName()+\" BEGIN!\");\n\n                        /// Collect the new collision\n                        currentCollisions.Insert(weakRB);\n\n                    }else{\n                        /// Send \"collision ongoing\" event\n                        newData[OnGhostCollisionStay::P_BODY] = RB;\n                        newData[OnGhostCollisionStay::P_GHOST] = ghostObject_;\n                        newData[OnGhostCollisionStay::P_GHOSTNODE] = node_;\n                        RB-\u0026gt;GetNode()-\u0026gt;SendEvent(GHOST_COLLISION_STAY, newData);\n                        URHO3D_LOGINFO( RB-\u0026gt;GetNode()-\u0026gt;GetName()+\" STAY!\");\n                    }\n\n\n            }\n        }\n\n        /// Process any collisions which have ended\n        for(auto it=prevCollisions.Begin();it!=prevCollisions.End();it++){\n\n            /// Check that the object has not been destroyed, and that the collision has ceased\n            if( (*it)!=nullptr \u0026amp;\u0026amp;  !currentCollisions.Contains(*it))\n            {\n                VariantMap\u0026amp; newData = GetEventDataMap();\n                newData[OnGhostCollisionEnded::P_BODY] = *it;\n                newData[OnGhostCollisionEnded::P_GHOST] = ghostObject_;\n                newData[OnGhostCollisionEnded::P_GHOSTNODE] = node_;\n                (*it)-\u0026gt;GetNode()-\u0026gt;SendEvent(GHOST_COLLISION_ENDED, newData);\n                URHO3D_LOGINFO( (*it)-\u0026gt;GetNode()-\u0026gt;GetName()+\" ENDED!\");\n            }\n\n        }\n\n        /// Keep track of collisions across frames\n        prevCollisions = currentCollisions;\n    }\n\n}\u003c/code\u003e\u003c/pre\u003e","post_number":1,"post_type":1,"updated_at":"2020-02-17T09:50:05.731Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":119,"reads":50,"readers_count":49,"score":620.0,"yours":false,"topic_id":5215,"topic_slug":"support-for-ghostobject-collision-events","display_username":"Leith Ketchell","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":4,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"https://discourse.urho3d.io/t/handling-melee-damage/5927/18","internal":true,"reflection":true,"title":"Handling Melee Damage","clicks":0}],"read":true,"user_title":"suspended user","title_is_group":false,"bookmarked":false,"actions_summary":[{"id":2,"count":1}],"moderator":false,"admin":false,"staff":false,"user_id":1098,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"user_suspended":true,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":30114,"name":"","username":"Lumak","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/l/8491ac/{size}.png","created_at":"2019-06-05T16:55:20.609Z","cooked":"\u003cp\u003eAfter googling the Bullet’s Kinematic Character Controller and issues related with it, what you’re proposing will become essential if one needs to know about the kinematic character collision.  And the routines you’ve written are very close to how the PhysicsWorld::SendCollisionEvents() is written IIRC.\u003c/p\u003e\n\u003cp\u003eIt looks good to me and would like to see a github project of this for people to test, if possible.\u003c/p\u003e","post_number":2,"post_type":1,"updated_at":"2019-06-05T16:55:20.609Z","reply_count":1,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":41,"readers_count":40,"score":58.2,"yours":false,"topic_id":5215,"topic_slug":"support-for-ghostobject-collision-events","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[{"id":2,"count":3}],"moderator":false,"admin":false,"staff":false,"user_id":256,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":30115,"name":"Leith Ketchell","username":"Leith","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png","created_at":"2019-06-06T01:53:22.196Z","cooked":"\u003cp\u003eAlthough the code I’ve presented could be optimized, I have taken advantage of several logical optimizations: mainly, I’ve leveraged the fact that we are working with a reduced list of candidate objects, and since my use-case did not require me to gather and send contact information (ie hit points and normals), I didn’t have to bother with that stuff.\u003cbr\u003e\nMy use-case also did not require three separate collision events, but I thought it would be astute (as you noticed) to model my solution on Urho’s existing one.\u003c/p\u003e\n\u003cp\u003eThis is, nonetheless, a clumsy workaround.\u003cbr\u003e\nIdeally, I should write a custom component that implements/wraps GhostObject, and adjust my character controller component to expect that sibling component (similar to RigidBody and CollisionShape). I think that would make a far better candidate for any future PR.\u003c/p\u003e\n\u003cp\u003e[EDIT]\u003cbr\u003e\nI’ve just tested the code and it appears to work perfectly.\u003cbr\u003e\nI’ve registered the ragdoll bodyparts of my zombie armature (rigidbodies) as “senders” of ghost collision events, and I am receiving the events in a separate controller component. My code uses the rigidbody parent node as the event sender, so that is the sender we should provide per rigidbody when registering to receive these events.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-auto\"\u003e/// Handle collisions between zombie bodyparts and ghost objects (ie player character's physics hull)\nvoid DynamicCharacter::OnGhostStart(StringHash eventType, VariantMap\u0026amp; eventData){\n\n    using namespace OnGhostCollisionBegin;\n\n    /// Unpack pointer to RigidBody, and query it for its owner node\n    RigidBody* rb = static_cast\u0026lt;RigidBody*\u0026gt;(eventData[P_BODY].GetPtr());\n    Node* rbnode = rb-\u0026gt;GetNode();\n\n    /// Unpack pointer to ghost object\n    /// TODO: pass this object using a WeakPtr to guard against object invalidation\n    btPairCachingGhostObject* ghost =  static_cast\u0026lt;btPairCachingGhostObject*\u0026gt;(eventData[P_GHOST].GetVoidPtr());\n    \n    /// Unpack pointer to ghost's owner node\n    /// TODO: Tag that owner node with pointer to its character controller!\n    Node* gn = static_cast\u0026lt;Node*\u0026gt;(eventData[P_GHOSTNODE].GetPtr());\n\n    /// Now do something useful with this information!\n    /// If the zombie is not performing an attack, we'll ignore this collision.\n    /// But if the zombie is attacking, we'll make it count!\n    ///\n    if(okToAttack_==false) // ie zombie is attacking!\n    {\n        /// Temporarily disable ghost collisions (1.5 seconds) on this zombie character\n         ignoreCollisions_ = true;\n         ignoreCollisionsTimer_ = 0;\n\n        /// Query ghostnode for its owner character controller        \n         \n        /// Zombie Deals Damage To Player Character !!\n\n    }\n\n}\u003c/code\u003e\u003c/pre\u003e","post_number":3,"post_type":1,"updated_at":"2019-06-06T05:28:34.736Z","reply_count":1,"reply_to_post_number":2,"quote_count":0,"incoming_link_count":0,"reads":36,"readers_count":35,"score":27.2,"yours":false,"topic_id":5215,"topic_slug":"support-for-ghostobject-collision-events","display_username":"Leith Ketchell","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":7,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":"suspended user","title_is_group":false,"reply_to_user":{"username":"Lumak","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/l/8491ac/{size}.png"},"bookmarked":false,"actions_summary":[{"id":2,"count":1}],"moderator":false,"admin":false,"staff":false,"user_id":1098,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"user_suspended":true,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":30120,"name":"Leith Ketchell","username":"Leith","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png","created_at":"2019-06-06T12:40:59.530Z","cooked":"\u003cp\u003eHappy to explain this further, because its interesttng how urho eventing works and where we can step in and what implications that has, and I am open to the idea that i may still not quite get it, that i can learn more\u003c/p\u003e","post_number":4,"post_type":1,"updated_at":"2019-06-06T12:40:59.530Z","reply_count":0,"reply_to_post_number":3,"quote_count":0,"incoming_link_count":0,"reads":33,"readers_count":32,"score":21.6,"yours":false,"topic_id":5215,"topic_slug":"support-for-ghostobject-collision-events","display_username":"Leith Ketchell","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":"suspended user","title_is_group":false,"reply_to_user":{"username":"Leith","name":"Leith Ketchell","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png"},"bookmarked":false,"actions_summary":[{"id":2,"count":1}],"moderator":false,"admin":false,"staff":false,"user_id":1098,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"user_suspended":true,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":30138,"name":"Leith Ketchell","username":"Leith","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png","created_at":"2019-06-08T04:32:43.727Z","cooked":"\u003cp\u003eSlightly off-topic:\u003cbr\u003e\nReally my collision logic, as I am showing it, is stupidly simple - if a zombie is attacking you, and any part of its body touches your hull, then you are damaged - since I have information about the bodyparts involved as well as the state of the characters involved, I can certainly make more informed decisions about how damage is dealt, but we start with the “basics”, being able to detect and respond to certain states in the game in a highly contextualized fashion.\u003cbr\u003e\nI needed to know more than just, a zombie bumped into me, I needed deeper information about the contact than could be provided by simple collision hulls alone. I may go further and add a full armature to the player character too, and set up a matrix of collision handlers to deal with the extra information in a structured way.\u003c/p\u003e","post_number":5,"post_type":1,"updated_at":"2019-06-08T04:39:13.486Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":27,"readers_count":26,"score":7.4,"yours":false,"topic_id":5215,"topic_slug":"support-for-ghostobject-collision-events","display_username":"Leith Ketchell","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":2,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":"suspended user","title_is_group":false,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":1098,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"user_suspended":true,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false}],"stream":[30112,30114,30115,30120,30138]},"timeline_lookup":[[1,1267],[2,1266],[5,1264]],"suggested_topics":[{"id":7344,"title":"Do we give up supporting dx11？","fancy_title":"Do we give up supporting dx11？","slug":"do-we-give-up-supporting-dx11","posts_count":3,"reply_count":1,"highest_post_number":3,"image_url":null,"created_at":"2022-11-03T09:37:37.893Z","last_posted_at":"2022-11-03T13:09:15.153Z","bumped":true,"bumped_at":"2022-11-03T15:28:58.128Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":78,"category_id":9,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster","user":{"id":1510,"username":"SoNewBee","name":"So New Bee","avatar_template":"/user_avatar/discourse.urho3d.io/sonewbee/{size}/3755_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":263,"username":"1vanK","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/1vank/{size}/768_2.png"}}]},{"id":7304,"title":"Urho3D is crashing on Android 12","fancy_title":"Urho3D is crashing on Android 12","slug":"urho3d-is-crashing-on-android-12","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-07-28T10:03:51.280Z","last_posted_at":"2022-07-28T10:03:51.349Z","bumped":true,"bumped_at":"2022-07-28T10:38:06.014Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":126,"category_id":9,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":809,"username":"elix22","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/elix22/{size}/1437_2.png"}}]},{"id":7347,"title":"How does Urho handle script objects each frame?","fancy_title":"How does Urho handle script objects each frame?","slug":"how-does-urho-handle-script-objects-each-frame","posts_count":3,"reply_count":1,"highest_post_number":3,"image_url":null,"created_at":"2022-11-08T02:33:56.461Z","last_posted_at":"2022-11-08T14:46:09.857Z","bumped":true,"bumped_at":"2022-11-08T14:46:09.857Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":64,"category_id":9,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster","user":{"id":1292,"username":"evolgames","name":"evol","avatar_template":"/user_avatar/discourse.urho3d.io/evolgames/{size}/3169_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}}]},{"id":7160,"title":"RayCast trouble","fancy_title":"RayCast trouble","slug":"raycast-trouble","posts_count":17,"reply_count":9,"highest_post_number":19,"image_url":null,"created_at":"2022-01-29T00:06:00.367Z","last_posted_at":"2022-01-30T00:29:39.356Z","bumped":true,"bumped_at":"2022-01-30T00:29:39.356Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":3,"views":260,"category_id":10,"featured_link":null,"has_accepted_answer":true,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster, Accepted Answer","user":{"id":861,"username":"GodMan","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/g/e79b87/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":627,"username":"George1","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/g/9e8a1a/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":1038,"username":"dertom","name":"Thomas Trocha","avatar_template":"/user_avatar/discourse.urho3d.io/dertom/{size}/1815_2.png"}}]},{"id":7345,"title":"Preserving a large sprite array?","fancy_title":"Preserving a large sprite array?","slug":"preserving-a-large-sprite-array","posts_count":4,"reply_count":1,"highest_post_number":4,"image_url":null,"created_at":"2022-11-03T11:35:59.907Z","last_posted_at":"2022-11-08T14:24:54.460Z","bumped":true,"bumped_at":"2022-11-08T14:24:54.460Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":4,"views":69,"category_id":10,"featured_link":null,"has_accepted_answer":true,"posters":[{"extras":"latest","description":"Original Poster, Most Recent Poster, Accepted Answer","user":{"id":1292,"username":"evolgames","name":"evol","avatar_template":"/user_avatar/discourse.urho3d.io/evolgames/{size}/3169_2.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":1363,"username":"vmost","name":null,"avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png"}}]}],"tags_descriptions":{},"id":5215,"title":"Support for GhostObject collision events","fancy_title":"Support for GhostObject collision events","posts_count":5,"created_at":"2019-06-05T04:18:37.316Z","views":779,"reply_count":2,"like_count":6,"last_posted_at":"2019-06-08T04:32:43.727Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"support-for-ghostobject-collision-events","category_id":9,"word_count":1319,"deleted_at":null,"user_id":1098,"featured_link":null,"pinned_globally":false,"pinned_at":null,"pinned_until":null,"image_url":null,"slow_mode_seconds":0,"draft":null,"draft_key":"topic_5215","draft_sequence":null,"unpinned":null,"pinned":false,"current_post_number":1,"highest_post_number":5,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":false,"bookmarks":[],"topic_timer":null,"message_bus_last_id":0,"participant_count":2,"show_read_indicator":false,"thumbnails":null,"slow_mode_enabled_until":null,"tags_disable_ads":false,"details":{"can_edit":false,"notification_level":1,"participants":[{"id":1098,"username":"Leith","name":"Leith Ketchell","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png","post_count":4,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":1},{"id":256,"username":"Lumak","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/l/8491ac/{size}.png","post_count":1,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2}],"created_by":{"id":1098,"username":"Leith","name":"Leith Ketchell","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png"},"last_poster":{"id":1098,"username":"Leith","name":"Leith Ketchell","avatar_template":"/user_avatar/discourse.urho3d.io/leith/{size}/2384_2.png"}}}